
		Spice3toHabala'2000:  history 29.12.99 - ...
		--------------------------------------------
	(Этот протокол работ - неформальный, ведется разработчиком для себя)


Date	Rev.	What's new?
----	----	---------------------------------------------------------------

22.12		первый звонок

29.12	0.01	подготовительные работы:
#1		- заготовки всех *.H-файлов
		- начат SHmain.C - обработка ком.строки, ф-ции в/в

30.12	0.02	- продолжение SHmain.C
#2		- начат SHfun.C - дополнительные функции

31.12	0.03	- SHmain.C, SHfun.C ... 
#3		- makefile
		- SHlpars.L, SHpars.Y - пока копии из другого компилятора

02.01	0.04	spice_id.txt - синтаксические элементы входного языка Spice
#4		spice.g - грамматика
		SHlpars.L, SHpars.Y - по образцу из spice_id.txt взяты
		  ключевые слова и обозначения элементов электрической схемы

	0.05	SHpars.Y - по образцу из spice.g начата грамматика

03.01	0.06	SHlpars.L:
#5		- возврат лексемы FLOATNUM
		- Ldebug()
		SHpars.Y:
		- переписана FindLexem()/FindToken()
		- продолжен ввод грамматики

	0.07	SHpars.Y:
		- закончен черновой ввод грамматики
		SHpass1.C, SHpass2.C, SHpass1.H, SHpass2.H - начаты
		отлажен makefile

04.01	0.08	SHpars.Y:
#6		- доделки грамматики
		- ! в грамматике, описанной в spice.g есть конфликты/ошибки:
		  - в описании ParameterType закоментарены правила, вызывающие
		    shift/reduce конфликты

	0.09	SHmain.C:
		- закончены ф-ции ввода/вывода
		- отладка обработки командной строки и флагов
		- перенос сообщений в SHmsgEN.H

05.01	0.10	задышало - неправильно работает лексический анализ - отладка
#7

06.01	0.11	SHlpars.L: продолжение отладки лексического анализатора:
#8		- убран из распознавания spice-идентификатор, который может
		  начинаться с цифры
		- идентификатор может распознаваться как ЭлементСхемы,
		  если только он стоит в начале строки, в другой части строки
		  он будет распознаваться как идентификатор
		- обработка комментариев "*..." и "... ;..."
		- не распознается кириллица в строках
		  (нельзя "рашн", можно "english")

	0.12	SHpars.Y:
		- жалкое подобие обработки ошибок
		SHlpars.L:
		- отлажен перенос операторов
		- обработка суффиксов-множителей типа 150k, 123.85u
		  все результаты ложатся в yylval.floatnum (типа double)

07.01	0.13	SHpars.Y:
#9		- не выдавать стандартную диагностику YACCа (yyerror()),
		  а только свои MsgCompile()
		SHcommon.H:
		- # define TABSIZE 8 и заменить везде 8 на TABSIZE
		SHlpars.L:
		- при вкраплениях русских букв распознаватель крахует,
		  добавление правила для [\128-\255] приводит к зависанию
		  самого Lex'а, эмпирическим путем вычислен работающий
		  диапазон [\128-\241] - используется для вылавливания
		  как одиночного (ошибочного) символа, так и внутри
                  строки символов ("..."):
		  - вставка в правила {EXTSYM} = [\128-\241] приводит
		    к некорректной работе распознавателя, глюкам
		  - попытки обработки кириллицы _прекращены_, любой
		    символ по-прежнему в правилах обозначается (.),
		    а не (.|{EXTSYM}), и он не описывает диапазон [\128-\255]
		  ! при классическом описании (.) в комментариях расширенные
		    символы работают, но не отображаются при контрольной печати,
		    в других местах они либо вызывают ошибки, либо зацикливание
		    распознавателя (и бесконечному выводу диагностики),
		    прерывать надо с помощью CTRL+BREAK !
		- во всех правилах, имеющих левым контекстом начало строки,
		  возможны пробелы/табуляции: ^[ \t]*...
		- во всех правилах, куда влезла табуляция, переделать
		  пересчет позиции:
		  - в правилах, имеющих левым контекстом начало строки
		    с возможными лидирующими пробелами: "^[ \t]*..." :
		    - начало "* комментария"
		    - перед именем элемента схемы в начале строки
		  - в обработке продолжения оператора на другую строку
		  - внутри лексемы-строки
		- исправлена диагностика строки и позиции для концов строки
		  и комментария (Lex сам переводит номер строки yyleneno при
		  распознавании '\n', но ведь это еще предыдущая строка)
		- отладочные сообщения оставлены пока в SHlpars.L, а основные
		  сообщения и их части - в SHmsgEN.H

	0.14	во всех *.H-файлах (кроме SHcommon.H) сделано:
			# ifndef ИМЯФАЙЛА_H
			# define ИМЯФАЙЛА_H
				<тело>
			# endif /* define ИМЯФАЙЛА_H */
		SHfun.C переименована в SHiofun.C, переделан makefile
		SHlpars.L: подготовка к обработке .INCLUDE
		- при печати диагностики номера строки в ShowLine() перед
		  номером строки ставить имя файла
		- то же в SHiofun.C:MsgCompile()
		SHlpars.L:
		- первая строка - титульная - не анализировать, а пропускать
		- SkipLine();
		- вставлено правило "<CODE>^[ \t]*"."{INCLUDE}", но пока
		  не обрабатывается, а просто извлекается имя файла
		  в nameFileInp и пропускается остаток строки SkipLine();

08.01	0.15	SHlpars.L:
#10		- в правиле поиска .ключевых_слов добавлен левый контекст
		  начало строки с возможными пробелами
		  - правило <CODE>"."{LETTER}({IDLETTER}|{DECDIGIT})*
		    заменено на <CODE>^[ \t]*"."{LETTER}+
		- пересчет позиции
		- удаление лидирующих пробелов
		- обработка .INCLUDE перенесена в правило по обработке
		  .ключевых_слов

	0.16	SHlpars.L:
		- суффиксом числа может быть любая строка, из которой надо
		  только извлекать множитель, а единица измерения ясна из
		  контекста, поэтому она отбрасывается, то есть
		  2.5mA = 2.5e-3 = 1.5mV,  1kOhm = 1000 = 1e3 = 1kHz и т.п.
		  поэтому изменены соответствующие 2 правила и обработка
		  суффикса в них:
		    LookupScale( sfx ) ищет теперь не точное совпадение
		    суффикса с эталоном, а вхождение каждого из эталонов
		    суффикса-множителя как подстроки
		SHpars.Y:
		- в правила внесен нетерминал Value:DECINTNUM|FLOATNUM;
		  возвращающий значение - именно его надо использовать в
		  качестве значений величин
		Для обработки .INCLUDE:
		- SHiofun.C: сделаны ф-ции OpenInput(имя_файла) и CloseInput(),
		  открывающие/закрывающие оба файла fileInp и fileInpDbl
		  и устанавливающее nameFileInp = имя_файла/пустая_строка
		- SHmain.C: открывать/закрывать вх.файл только этими функциями
		- SHiofun.C: функция проверки существования файла FileExist(имя)
		SHlpars.L: обработка .INCLUDE:
		- обработка .INCLUDE-правила:
		  - проверка существования нового файла
		  - если файла нет, сообщить и ничего не делать
		  - PushFileStack( nameFileInp/*ИмяСтарогоФайла*/,
				   ++yylineno/*НомерСледСтроки*/);
		  - если результат PushFileStack() == FALSE, переключение на
		    другой файл не производить
		  - CloseInput();
		  - OpenInput( nameFileNew/*ИмяНовогоФайла*/ ),
                    где nameFileInp = nameFileNew;
		  - установка номеров строки = 1(0?) и позиции = 0,
		    признака необработки первой (титульной) строки нового файла
		  - MsgConsole('\n'), чтобы при выводе на консоль специально
		    не затирать предыдущие "\rFile %s: line %s\r"
		  - переход к началу разбора:
		    - return _ENDOFSTMT_
		  ? неверно считаются позиции 1-й строки во включенном файле:
		    оказалось, что в буфере Lex'а остался один символ от старого
		    файла, поэтому при обнулении номеров строки и позиции
		    (см.выше) надо также сбросить этот символ
		итог дня: переключение на новый файл происходит, обработка
		  номеров строки и позиции лексем производится правильно,
		  запоминание (файла,строки) в стеке пока не сделано,
		  возврат к старому файлу еще не производится
		SHmain.C, SHlpars.L: вероятно, поднимать регистр в именах
		  файлов не надо - закомментарено

09.01	0.17	SHmain.C: добавлен флаг командной строки '-g' для отладки
#11		  синтаксического анализатора
		SHlpars.L: продолжение обработки .INCLUDE:
		- в ф-ции yywrap() при достижении конца файла:
		  - CloseInput();
		  - проверять наличие файла(ов) в стеке
		    ( это был включенный файл ? ):
		    - если нет - return !0;
		      (все закрыть Done() и выйти из всей прог-мы)
		    - если есть:
			- PopFileStack(ИмяСтарогоФайла, НомерСледСтроки);
			- fileNameInp = ИмяСтарогоФайла;
		        - OpenInput( fileNameInp/*ИмяСтарогоФайла*/ );
			- перемотать открытый файл на НомерСледСтроки
			- SHiofun.C: сделана SkipLines( file, linenum );
			- yylineno/*yyTokenLine*/ = НомерСледСтроки;
			- unput('\n') для распознавания строки как нового
			  оператора, а не продолжения
			- установить НомерСледСтроки, позицию = 0
			- return 0; - продолжить разбор
		- PushFileStack() и PopFileStack() сделаны для обработки
		  многоуровневой вложенности .include-файлов
		! так как возможно рекурсивное зацикливание процедуры вставки
		  файлов, введена константа maxINCLNEST, сообщение msgMAXINCLNEST
		  - пока уровень вложенности ограничен числом 32 (?)
		? многоуровневая вложенность .include-файлов работает,
		  а одноуровневая - нет: при открытии еще одного файла
		  на этом же уровне у него обработка идет со 2-й стороки
		  и делается попытка чтения после <EOF>, что вызывает ош-ку:
		  - надо в правиле .INCLUDE: ln = /*yylineno*/yyTokenLine + 1;
	?	  - в yywrap() неверно работает SkipLines( fileInp , --lno );
	?	  - ShowLine() неверно работает PrintLine( fileDebug, yyTokenLine );
	???	- вроде причина была в том, что при возврате переопределенной
		  функцией yywrap() значения TRUE лексический анализатор не
		  останавливался, а подолжал работать дальше - теперь вместо
		  return TRUE делается Done(); exit(...);
		- надо делать "begin CODE;" при открытии нового файла !!!

10.01	0.18	и все-таки что-то не так с обработкой .include:
#12		? некоторые включенные файлы начинают обрабатываться со 2-й
		  строки, а некоторые с 1-й !?? - показалось ...
		- иногда вложенность доходит до ~10 уровня и дальнейшее
		  вложение прекращается - виновата ф-ция SHiofun.C:FileExist(),
		  тестирующая наличие включаемого файла
		  (она возвращает strerror(errno) = "File not found..." !??)
		  - эта проверка убрана, просто в случае неудачного открытия
		    файла происходит возврат к предыдущеме файлу из стека
		перенесена проверка количества include-вложений из ф-ции
		  PusFileStack() в правило, обрабатываюшее .INCLUDE, чтобы зря
		  не закрывать, а потом не восстанавливать текущий файл

11.01	0.19	косметические изменения диагностики
#13		попытка победить yywrap(), возвращающую значение TRUE, что не
		  приводит к выходу из yylex(), хотя в сгенерированном Lex'ом
		  тексте ясно прописано:
			while((nstr = yylook()) >= 0)
			yyfussy: switch(nstr){
				 case 0:
					if(yywrap()) return(0); break;
				 case ...
		  может виновата ф-ция yylook(), прототип которой - в ncform.c?
		  нет, 0 возвращается yylex() в YACC
		  - "вылечилось" добавлением CloseInput() перед возвратом ф-цией
		    yywrap() значения TRUE, но теперь в конце обработки любого
		    файла дается сообщение Read error on input file, которую
		    выдает PrintLine(), вероятно для какой-то пердсмертной
		    диагностики из MsgCompile(), поэтому выход при ошибочном
		    чтении закомментарен, вместо него - печать пустой строки и
		    возврат из функции:
		     if( fgets( linebuffer, MAXINPLINELEN, fileInpDbl ) == NULL ){
			/* MsgErrorFatal( exitINPFAIL, msgINPFAIL, nameFileInp ); */
			fprintf( fileDiag, "%n" );
			return; /*!*/
		     }
                  - но такое решение приводит к бесконечным циклам в случае,
		    если в главном входном файле последняя строка не пустая (!?)
		  - поэтому в начале функции yylexx() перед самыми правилами
		    поставлено:
		     /* return EOF if input closed: */
		     if( fileInp == NULL )    return 0;
		     if( fileInpDbl == NULL ) return 0;
		  - зато теперь выход из yylex() корректен и вызов второго
		    прохода компилятора можно не делать из yywrap() !
		  - и все-таки зависания возникают, поэтому в начале PrintLine()
		    поставлена проверка:
		     if( fileInpDbl == NULL ) return;
		  - такая же проверка поставлена и в MsgCompile():
		     if( fileInp == NULL )    return;
		     if( fileInpDbl == NULL ) return;
		  ! истинная причина зависаний была в том, что из синтаксического
		    анализатора yyparse() нет return в случае обнаружения конца
		    файла (yylex() возвращает 0), а только после .END

12.01	0.20	продолжение борьбы:
#14		- после ошибки в *.Y надо обязательно делать yyclearin;
			#define yyclearin yychar = -1
		- при удачном закрытии каждого файла обнуляю указатель на него,
		  после чего наблюдается зависание при большой рекурсивной
		  вложенности файлов
		- зависание происходит только для рекурсивно вложенных файлов,
		  в последнем из которых последняя строка не завершается '\n'
		  после того как при достижении максимального уровня вложенности
		  начинается обратное сворачивание - на последней строке:
		  - либо не давшей при разборе _ENDOFSTMT_ после комментария
		  - либо не давшей .ENDS после оператора
		  начинаются бесконечные вызовы yylex() из yyparse(), не взирая
		  на то, что yylex() возвращает 0 - проверено
		- макропеременная INCL_NEST_EXCEED_IS_FATAL теперь определяет,
		  будет ли превышение уровня вложений приводить к прекращению
		  компиляции или игнорировать недопустимый .include

	0.21	борьба с зацикливанием при больших вложенностях или отсутствии
		  директивы .END закончилась добавлением правила:
		Program : StatementList error  ={
                            YERRMSG( "Need .END at the end of file" );
                            return cntErrors;   } /* _ENDOFSTMT_ */ ;
		отладочные сообщения перенесены из SHlpars.L в SHmsgEN.H

		выяснилась наприятная особенность Spice: 0 и 00 - это разные
		  лексемы: это может быть и число, и идентификатор !!!
		  - прийдется все возвращать как идентификаторы, а обработку
		    возможных значений переносить в YACC (в том числе обработку
		    суффиксов-множителей!), либо в качестве возвращаемого
		    значения выдавать указатель на пару ( вид(=yytext),
		    значение(значение*множитель=double) )
		  - решено оставить старые лексемы:
		    IDENTNAME	{IDLETTER}({IDLETTER}|{DECDIGIT})*
		    (чистые числа из-за +-, но с суффиксом):
		    DECINTNUM:
			DECIMALNUM  [-+][0-9]+
                        DECIMALSFX  [-+][0-9]+[0-9A-Za-z_]*
					( было DECIMALNUM: [-+]?{DECDIGIT}+ )
		    FLOATNUM:  (есть +-)
			({FLOAT_1S}|{FLOAT_2S}|{FLOAT_3S}|{FLOAT_4S}){LETTER}*
		    где	FLOAT_1S    [-+][0-9]+"."[0-9]*([eE][-+]?[0-9]+)?
			FLOAT_2S    [-+]?[0-9]+"."[0-9]*[eE][-+][0-9]+
			FLOAT_3S    [-+][0-9]+[eE][-+]?[0-9]+
			FLOAT_4S    [-+]?[0-9]+[eE][-+][0-9]+

13.01	0.22	SHiofun.C: в PrintLine() добавлена проверка того, завершается
#15		  ли строка '\n', если нет, производится дописывание '\n'
		  в конец строки
		SHlpars.L:
		- опять изменения:
			SCALESUFX   [FfPpNnUuMmKkGgTt][0-9a-zA-Z]*
			    /* clear number (include "+-.e"): */
			DECIMAL_NUM [-+][0-9]+
			FLOAT1S     [-+][0-9]+"."[0-9]*([eE][-+]?[0-9]+)?
			FLOAT2S     [-+]?[0-9]+"."[0-9]*[eE][-+][0-9]+
			FLOAT3S     [-+][0-9]+[eE][-+]?[0-9]+
			FLOAT4S     [-+]?[0-9]+[eE][-+][0-9]+
			FLOAT1E     [-+]?[0-9]+"."[0-9]*[eE][-+]?[0-9]+
			FLOAT2E     [-+]?[0-9]+[eE][-+]?[0-9]+
			FLOAT1P     [-+]?"."[0-9]+([eE][-+]?[0-9]+)?
			FLOAT_NUM   ({FLOAT1S}|{FLOAT2S}|{FLOAT3S}|{FLOAT4S}|{FLOAT1E}|{FLOAT2E}|{FLOAT1P})

			     /* number-identifier: */
		/*new*/	DECIMAL_ID  [0-9]+
			FLOAT1ID    [0-9]+"."[0-9]*
			FLOAT2ID    [0-9]+(".")?[0-9]*[eE][0-9]+
			FLOAT3ID    [0-9]+[eE][0-9]+
		/*new*/	FLOAT_ID    ({FLOAT1ID}|{FLOAT2ID}|{FLOAT3ID})
		- правила возвращают:
			<CODE>{FLOAT_NUM}({SCALESUFX})?   /* float number */
			<CODE>{FLOAT_ID}({SCALESUFX})?    /* float identifier */
			<CODE>{DECIMAL_ID}({SCALESUFX})?  /* decimal identifier */
			<CODE>{DECIMAL_NUM}({SCALESUFX})? /* +- decimal num with scale suffix */
		- убрано правило:
		    {DECIMAL_NUM} { /* +- decimal number without suffix */
		! оказалось, что нельзя писать ...{SCALESUFX}? , а надо
		  ...({SCALESUFX})? , иначе - глюк ('?' относится ко всему ?)
		! суффикс в числах-идентификаторах искать с начала строки !
		- решено ввести новые типы лексем (и число с коэффициентом
		  и идентификатор одновременно):
		    IDENTINT		[0-9]+[0-9A-Za-z_]*
		    IDENTFLOAT:
			FLOAT_1ID	[0-9]+"."[0-9]*
			FLOAT_2ID	[0-9]+[0-9A-Za-z_\.]*
		    для этих сохранения значения лексем создана специальная
		    структура:
			typedef struct {
			    char   *text;
			    long   longval;
			    double floatval;
			} value;
		    и в %union добавлено:  value   *mixed;
		- в IDENTFLOAT неправильно выделяется суффикс

	0.23	SHlpars.L:
		- неверно обрабатывается суффикс MEG - исправлено
		- не опознается FLOAT+SUFFIX - надо конструкцию {...}|{...}|...
		  необходимо обязательно брать в круглые скобки
		- исправление обработки суффикса для IDENTFLOAT
		- 7_7 распознается как целое 7 и идентификатор _7 - исправлено
		  правило для идентификатора - первой м.б. только буква
		- '4e10XXX' '3.3xxx' '000xxx' '5e5e' не распознаются как единое
		  целое, а разбиваются на части, поэтому:
		- изменено правило суффикса с
			SCALESUFX   [FfPpNnUuMmKkGgTt][0-9a-zA-Z]*
		  на	SCALESUFX   {LETTER}[0-9a-zA-Z]*
		- и чтобы все подобное воспринималось как ошибочная лексема
		  вместо правила
			   <CODE>.                { /* unrecognized symbol */ ...
		  сделано  <CODE>[^ \t\n-+(),=.]+ { /* unrecognized token */ ...
		- теперь не распознаются вообще '000xxx' '5e5e' '7_7'
			'1e-6' '6e-10' '4e10XXX' '4e-10mXX'
		- правило "unrecognized token" надо менять, поэтому за ним
		  восстановлено правило "unrecognized symbol",
		  для "unrecognized token" попробованы:
		  [^ \t\n-+(),=.].*	- распознает целиком почти всю строку
			как лексему
		  [^ \t\n-+(),=.]*	- вызывает ошибку "too many transition"
			(надо %A2500) - распознает целиком почти всю строку
			как лексему и вызывает зависание в конце файла
		  [^ \t\n-+(),=.0-9]+	- чуть легче, но не распознаются
			идентификаторы длиной более 1 символа
		  [^ \t\n-+(),=.0-9]*	- то же
		  [^ \t\n-+(),=.]*	- разбиение на лексемы правильно,
			но все - unrecognized
		  [^ \t][^ \t\n-+(),=.]* - вызывает предупреждение и ошибку:
			(Warning) Non-portable character Class
			(Error) Output table overflow
		  [^ \t\n]*		- распознает 'L=34u' как единое
		  [^ \t\n=,()]*		- не распознаются '1.8e-4' '6e-10'
			'4e-10mXX' '4e10XXX' '-1e8KOHM' '8.5e-8MEGA' '2e10'
			'5e5e' '7_7'
		- правило "unrecognized token" пока закомментарено, такой
		  вариант - идеальный:
		  - '7_40' распозналось как 3 лексемы: IDENTINT = '7',
			unrecognized symbol = '_', IDENTINT = '40'
		  - '0.00x.xx' -> IDENTFLOAT = '0.00x' (значение = 0),
			SYMBOL = '.', IDENTNAME = 'xx'
		  - '5e5e'	-> FLOATNUM = '5e5e' (значение = 500000)
		  - 1E3		-> это FLOATNUM, а не целое с буквенным суффиксом

14.01	0.24	SHpars.Y: изменены правила (с возвратом значений):
#16		  Value : | DECINTNUM | FLOATNUM | IDENTINT | IDENTFLOAT ;
		  Name: только IDENTNAME
		  Node : IDENTNAME | IDENTINT | IDENTFLOAT ;
		  Identifier: только IDENTNAME
		  Name: то же, что и Node (Spice-идентификатор)
		другие изменения в грамматике:
		- в описании модели могут быть круглые скобки

15.01	0.25	если .include-файла не существует, при возврате в исходный файл
#17		  сбивалась нумерация строк - исправлено
	?	? могут ли иметь включаемые файлы титульную строку и .end
		  сейчас: во включаемом файле титул есть, а .end все завершает
		- в зависимости от # define INCL_FILE_HAVE_TITLE делается
		  2 варианта: титул есть / нет
	?	? выяснилось, что при описании модели в некоторых примерах
		  пары ПАРАМ=ЗНАЧ продолжаются на следующей строке без символа
		  продолжения "+", поэтому _в_грамматику_ прийдется внести
		  поправку в описании модели, разрешающую после каждой такой
		  пары делать _ENDOFSTMT_, но это порождает конфликт shift/reduce
		добавлено еще одно ключевое слово .OPTIONS и правило к нему

	0.26	изменены ключевые слова:
		  SEMRESISTOR -> RESISTOR, SEMCAPACITOR -> CAPACITOR
		на пробу: изменение в грамматике (по документации Spice3):
		- L: индуктивности
		- R: резисторы
		- C: конденсаторы
		  ( для R и C добавлены лексемы LENGTH и WIDTH)
		- K: связанные индуктивности (добавлена лексема INDUCTCOUPL)
		в вышеуказанные правила вставлены отладочные сообщения о
		  распознанных правилах
		SHlpars.L: добавлены новые лексемы - одиночные символы:
		- в документации (с.26) упомямуты операции
			+	-	*	/	^(power) -(унарный)
		- добавлены соответствующие лексемы, ассоциативности и правила
		- правило для описания модели переписано без конфликта, но
		  с возможностью продолжения на другие строки без символа
		  продолжения "+"
		- в TurboC2.0 какие-то проблемы с форматным выводом:
		  в функциях Ydebug() и Ldebug() строку
			MsgDebug( msgfmt, arguments );
		  пришлось заменить на
		        vsprintf( linebuffer, msgfmt, arguments );
			MsgDebug( linebuffer );
	!?	? выяснилось, что в описании модели бессмысленно делать переход
		  на другую строку без символа продолжения '+', так как Lex
		  опознает первую лексему в строке как элемент схемы, а не
		  как идентификатор, что порождает ошибку, поэтому сделана
		  попытка заменить правило
			ModelParameter : Identifier '=' Value ;
		  на	ModelParameter : ModelParm '=' Value ;
		  где	ModelParm может быть как идентификатором, так и
			допустимым элементом схемы
		- добавлен флаг '-2' для отладки второго прохода
		- добавлены правила для:
		  V-switch (Sxxx), I-switch (Wxxx)

17.01	0.27	SHpars.Y: другие изменения/дополнения в грамматике (по
#18		  документации Spice3):
		- Vxxx - Voltage, Ixxx - Current:
		  - добавлены ключевые слова DISTOF1, DISTOF2
		  - изменено SINGFREQ на SFFM
		- в отладочной информации добавлена печать узлов
		- в арифм. выражение добавлено правило с функцией:
		  ArExpr : Identifier '(' ArExpr ')' ;
		- переименованы лексемы:
		   "E",	LVCVS,	/* Linear Voltage-Controlled Voltage Sources */
		   "F",	LCCCS,	/* Linear Current-Controlled Current Sources */
		   "G",	LVCCS,	/* Linear Voltage-Controlled Current Sources */
		   "H",	LCCVS,	/* Linear Current-Controlled Voltage Sources */
                  добавлены правила к ним
		- во всех диагностических сообщениях, если в пара (строка,
		  позиция) имеет вид (nn,0), то сообщать надо (nn-1,end):
		  - MsgCompile(), здесь, кроме того, показывать предыдущую строку
		  - Ldebug()
		  - Ydebug()

	0.28	SHpars.Y: добавлено:
		+ Bxxx (NLDS)	/* Non-linear Dependent Sources */
		  - специально для правила ElemNLDS зарезервированы лексемы
		    "I" (I_SRC) и "V" (V_SRC)
	???	? что делать с арифметическим выражением - разбирать, но не
		  вычислять
		? или надо собирать воедино в том же виде, что и на входе ?
		+ Txxx (LLTLINE)  /* Lossless Transmission Lines */
		+ Uxxx (UDRCLINE) /* Uniform Distributed RC Lines (Lossy) */
		+ Oxxx (LTLINE)   /* Lossy Transmission Lines */,
		  добавилась "N" (лексема N_LUMPS)
	!!!	  ! теперь есть 6 запрещенных однобуквенных идентификаторов:
			L, W, F, I, V, N
		+ Dxxx (DIODE) + правила
		+ добавлено ключевое слово ".WIDTH"
		- в сообщениях ключевые слова взяты в кавычки

18.01	0.29	SHpars.Y: добавлено:
#19		- транзисторы
		    "Qxxx" (TRANSISTOR)  /* Bipolar Junction Transistors */
		    "Jxxx" (JFET)        /* Junction Field-Effect Transistors */
		    "Mxxx" (MOSFET)
		    "Zxxx" (MESFET)
		- SHlpars.L: для MOSFET пришлось добавить лексемы:
		    "AD",       AD,
		    "AS",       AS,
		    "PD",       PD,
		    "PS",       PS,
		    "NRD",      NRD,
		    "NRS",      NRS,
	!!!	! 740/750 states - критично !

	0.30	в связи с достижением критического числа состояний:
		- сменены YACC и LEX на те, к которым есть исходники и где
		  можно менять размеры таблиц, теперь максимальное число
		  состояний доведено до 1000
		- перестроена библиотека LEXLIB.LIB

19.01	0.31	в связи с возможными сбоями в нумерации строк при диагностике
#20		  в ошибочной диагностике YACC указывать имена элементов схемы
		обнаружился сбой в нумерации включаемых файлов, приводящий
		  к неверной выдаче диагностики в MsgCompile():
		  SHlpars.L:
		  - изменение в обработке .INCLUDE
		  - в ShowLine() и Ldebug() не печатать диагностику
		    для строк <=0
		SHpars.Y: продолжение редактирования грамматики:
		- .OPTIONS
		- .NODESET
		- .IC

	0.32	внесение изменений в VOLTAGE и CURRENT:
		? функции могут идти вперемешку с DC/AC/DISTOF параметрами
		! но это вызывает много конфликтов
		- пока сделано >=0 функций в конце правила после DC/AC/DISTOF
		с арифметическими выражениями делать ничего не надо - просто
		  разбирать и пропускать - действия закомментарены 
	!!!	в Turbo C 2.0 проект компилируется только для модели Huge,
		  для модели Small выдается ошибка "Floating point error: Domain."
		SHpars.Y: продолжение редактирования грамматики:
		- .SUBCKT
		- .AC (добавлен нетерминал DecInt - только целое число)
		- .DC ( .DCANAL ?)
		- .DISTO

20.01	0.33	SHpars.Y: продолжение редактирования грамматики:
#21		- .NOISE
		- ShowDecLinOct(): так как память под строки - зарезервированные
		  слова Lex'ом не выделяется, следующее правило неправильно
		  возвращает значение (причем возвращается значение предыдущей
		  распознанной лексемы):
			%token <strptr> DEC     OCT     LIN
			%type  <strptr> DECorOCTorLIN
			DECorOCTorLIN : DEC
				={ $<strptr>$ = $<strptr>1;
		                   Ydebug( "DECorOCTorLIN: '%s' := '%s'", $$, $1 );
				}
		  дает отладочную диагностику:
		   *lex* ln,pos=3,18:	find token IDENTNAME = 'vin4'
			- предыдущая распознанная лексема
		   *lex* ln,pos=3,22:	find token KEYWORD = 'dec'
		   *lex* ln,pos=3,22:		 keyword #329
			- нужная лексема (YTAB.H: # define DEC 329)
		   ##Y## #3.22:	DECorOCTorLIN: 'vin4' := 'vin4'
			- результат работы правила
		  поэтому:
			%token DEC     OCT     LIN
			%type  <longnum> DECorOCTorLIN
			DECorOCTorLIN : DEC
				={ $$ = iDEC;
				}
		  а ссылаться на значение-строку, возвращаемое данным нетерминалом,
		    надо так: ShowDecLinOct($n)
		- в добавление к изменениям, сделанным в v.0.27,0.31 - если пара
		  (строка,позиция) имеет вид (nn,0), то сообщать (nn-1,end) -
		  не распространять это на (1,0) - титульную строку:
		  - MsgCompile()
		  - Ldebug()
		  - Ydebug()
	?	- так как правило
		    Program :
			StatementList error
	        	        ={ MsgCompile( "Need .END at the end of file" );
        	        	   return cntErrors; 
	        	         }
		     /* _ENDOFSTMT_ */
			;
                  завершает работу программы на любом неверном .KEYWORD или
		  KEYWORD, идущем в начале строки вместо имени элемента схемы,
		  например:
		    VOL ...
		    CUR ...
		  - оно полностью закомментарено, что вызывает при отсутствии
		    .END сообщение "*FATAL* Read error on input file"
		SHpars.Y: продолжение редактирования грамматики:
		- .OP
		- .PZ		
		- .SENS (добавлена лексема _SENS)
		- .TF
		- .TRAN (изменена лексема _TRANS -> _TRAN)
	?	- остался лишний оператор .TLINE - закомментарен
		- добавлены лексемы _SAVE и _FOUR
	?!	! .SAVE Vector Vector ...
		  из-за того, что Vector может иметь вид @m1[id] , то в качестве
		  него может использоваться либо идентификатор, либо строка
		  (STRING), поэтому мною введено требование брать такой Vector
		  в кавычки "@m1[id]"
		- .PRINT
		- .PLOT
		- .FOUR
		- .SUBCKT (подцепь)
		- Xxxx (SUBCALL) - включение подцепи
	???	- правило
			CallSubCircuit /*Xxxx*/
			 :
			   SUBCALL SubCallNodeList Identifier
			       ={ Ydebug( "Call subcircuit '%s'", $3 ); }
			   _ENDOFSTMT_
			 ;
		  вызывает 2 конфликта reduce/reduce, так как Identifier
		  может быть очередным узлом списка SubCallNodeList

	0.34	SHpars.Y: черновой ввод грамматики закончен, начата отладка
		  (для сравнения оставлен старый SHpars.Y12, v.0.12)
		- добавлен флаг '-1' для диагностики из процедур первого прохода
		- сделаны процедуры P1debug() и P2debug() для отладочной
		  диагностики первого и второго прохода

21.01	0.35    всего на сегодня проект насчитывает ~3900 сторок исходников
#22		  с командными файлами плюс ~700 строк данный протокол работ
		статистика по SHpars.Y (states = 759 > 750 in standard YACC):
			105/127 terminals, 179/250 nonterminals
			363/500 grammar rules, 759/1000 states
			0 shift/reduce, 2 reduce/reduce conflicts reported
			179/250 working sets used
			memory: states,etc. 3435/5200, parser 550/4000
		SHpars.Y: отладка на контрольных примерах
		- обработка ошибок:
		  yyerrok;    -	обязательно, иначе на ошибочной лексеме
				происходит зацикливание с бесконечной выдачей
				одной и той же ошибки
		  yyclearin;  -	без этого распознаватель завершает работу на
				данной ошибке - происходит возврат из yyparse()
		  ! после ошибочной лексемы на всех дальнейших лексемах для
		    данного оператора будет генерироваться ошибка, поэтому
		    дальнейший разбор проводить бессмысленно - надо сбрасывать
		    остаток строки SkipRestLine() из *.L
		  - теперь обработка всех ошибочных операторов завершается
		    SkipRestLine()
		перенос сообщений об ошибках YACC в файл сообщений,
		  отладочная диагностика оставлена
		SHmain.C: отладочные флаги показывать только с ключом '-?'
		SHiofun.C: в CloseInput() не затирать nameFileInp, иначе
		  при невозможности открыть .include-файл не будет сообщаться,
		  в каком файле ошибка включения

22.01	0.36	SHpars.Y: возвращаемые строки-константы сделаны статическими
#23		внутри возвращающих их функций, чтобы не засорять разрастающийся
		исходник
		После тестирования на имеющихся примерах:
		- SHlpars.L: имя сетевого элемента может состоять из одной буквы
		    NETELSUFX изменено с [0-9a-zA-Z_]+ на [0-9a-zA-Z_]*
		    и пришлось теперь поменять местами правила, распознающие в
		    начале правила ключевые слова и сетевые элементы, чтобы,
		    например "L" опознавалось как индуктивность, а не ключевое
		    слово
		- для удобства поиска однобуквенных лексем-ключевых слов
		  переименованы:
		    FREQUENCY	-> F_FREQ
		    LENGTH	-> L_LEN
		    WIDTH	-> W_WIDTH
		- добавлен оператор .WIDTH с неясным синтаксисом, судя по
		  примерам - это пары "идентификатор = значение"
		- порядок опций в операторах SemiDiode, SemiTransistor,
		  SemiJFET, SemiMESFET, SemiMOSFET, ... - не строгий,
		  поэтому переписаны соответствующие правила,
		  поскольку опции не обязательные, для избежания конфликтов
		  введено отдельно правило без опций
		- в связи с (возможными) зависаниями правило
		     Program
			 : StatementList error
		                ={ MsgCompile( msgNEED_END );
		                   return cntErrors; 
		                 }
			   /* _ENDOFSTMT_ */
			 ;
		  опять разкоментарено, но изменена формулировка ошибки
		    (так как ошибка - фатальная с выходом, иначе - зависание):
		  - "недопустимая лексема в начале оператора
		     или отсутствует .END в конце файла"
		    "Invalid token at the begin of statement
		     or missing .END at the end of file"
	?	  но это уже не помогает !??
		  - сделана попытка ввести правило
			"Program : StatementList error _ENDOFSTMT_"
		    что привело к лишнему reduce/reduce, но не помогло
		- в качестве параметров модели может быть не только
		  "идентификатор = значение", "идентификатор",
		  но и просто "значение" (найдено в примерах)
	?x	- добавлено правило для обработки идентификаторов, совпадающих
		  по написанию с ключевыми словами:
		    ExtIdentifier : IDENTNAME | TEMP | L_LEN | ... ;
		  - ExtIdentifier используется в параметрах модели
	?!	  вероятно, прийдется убрать все (в т.ч. однобуквенные) лексемы,
		  встречающиеся в опциях вида "ключевое_слово = значение",
		  заменив их на "идентификатор = значение", проверяя
		  "идентификатор" на допустимость в данном контексте
		  (это, кстати, существенно облегчит грамматику)
		- в операторе .PRINT в качестве параметра может быть "строка"		  
	!	- порядок следования опций в ElemVOLTAGE и в ElemCURRENT может
		  быть произвольным, но есть одно _обязательное_ требование:
		  DC-опция с опущенным ключевым словом 'DC' должна идти первой,
		  иначе пояляется неоднозначность (другие опции могут иметь
		  опущенные значения), влекущая 24 конфликта shift/reduce
		  ! пока не учтен случай, когда DC-опция с опущенным ключевым
		    словом одна
	!!!	- на этом этапе YACC может выдавать диагностику о разрушении
		  (clobber) какого-то из внутренних массивов
		  (опять что-то переполняется)
		- правило ExtIdentifier пока убрано
	!fatal!	- модель может быть без параметров (на этом изменении
		  преодолеть clobber... YACC'а уже не удалось даже
		  перекомпиляцией последнего с увеличенными параметрами):
		  "fatal error: clobber of a array, pos'n 873, by -64, line 1326"

23.01	0.37	В связи с тем, что ресурсы YACC'а исчерпаны и в грамматике
#24		  есть противоречия, связанные с совпадениями ключевых слов
		  и идентификаторов, начата замена ключевых слов в конструкциях
		  типа L=... на идентификатры с последующей их проверкой на
		  допустимость с помощью функции
                  - int CheckKeyWord( char *ident, /*char *key1,*/ ... /*,""*/ );
		  и выдачи сообщения об ошибке функцией
		  - MsgAllowKeywords( char *msgfmt, char *ident,
			 /*char *key1,*/ ... /*,""*/ );
		на идентификаторы заменены ключевые слова:
		- "F" (F_FREQ)
		- "IC"
		- "TD"
		- "NL"
		- "Z0"
		- в правиле StmtTransmissionLine опции обрабатываются вручную
		- начата единая функция для отображения идентификаторов-ключевых
		  слов char *ShowKeyword( long tokencode );

24.01	0.38	В *.Y все %token оставлены, чтобы генерировались константы для
#25		  присваивания их в качестве значений нетерминалам и для
		  ShowKeyword()
		Сделана LookupKeyword() для всех таких лексем в *.L:
		- LookupKey() разделена на LookupKeyword() и LookupOperator()
		*.L: в начале строки распознавание ключевых слов убрано,
		  оставлены только сетевые элементы
		Сделан единый нетерминал OptionBeginKeyword для всех опций вида
		  "KEYWORD = ...", в нем делается LookupKeyword()
		заменены все ф-ции Show...() на единую
			char *ShowKeyword( long tokencode );
		убрано правило ExtIdentifier (оно не понадобится)
		сделано то, что не дал сделать "clobber" в v.0.36:
		- модель может быть без параметров 
		- в .SAVE параметром может быть OutVar
		- ElemVOLTAGE и в ElemCURRENT: учесть случай, когда DC-опция
		    с опущенным ключевым словом одна в операторе

25.01	0.39	продолжение замены ключевых слов на идентификаторы и переписывание
#26		  соответствующих правил:
		- "N" (N_LUMPS)
		- AD, AS, PD, PS, NRD, NRS /*for MOSFET*/
		- IC, OFF, L_LEN, W_WIDTH /*for MOSFET*/
	!	отключено распознавание ключевых слов в *.L (но в *.Y пока не
		  перенесено) в правиле:
		  <CODE>{LETTER}({IDLETTER}|{DECDIGIT})* {/* identifier or keyword */
		продолжение замены ключевых слов на идентификаторы и переписывание
		  соответствующих правил:
		- индуктивности (Lxxx, Kxxx)
		- резисторы (Rxxx)
		- конденсаторы (Cxxx)
		из *.L в *.Y перенесена ф-ция ShowKeyword() вместе с таблицей
		  ключевых слов KeysTab KeywordsTab[];
		для правильной печати указателя на конец строки при выдаче
		  диагностики об ошибке функция PrintLine теперь будет
		  возвращать длину напечатанной строки

26.01	0.40	! обработка ошибок в опциях производится с помощью функций:
#27		  - в MOSFET, LLTLopt:
		    - LookupKeyword() в правиле OptionStartKeyword,
		    - в основном правиле - switch по типам лексем
		    - изображение лексемы в виде строки дает ShowKeyword()
		    (этот вариант громоздкий и, вероятно, худший - оставлен
		     для пробы, кроме того, при ошибочном ключевом слове
		     выдает два сообщения об одной и той же ошибке - одно
		     нормальное (из OptionStartKeyword), другое глупое)
		  - в остальных: CheckKeyword() и MsgAllowKeywords()
		продолжение замены ключевых слов на идентификаторы и переписывание
		  соответствующих правил:
		- ElemVOLTAGE /*Vxxx*/, ElemCURRENT /*Ixxx*/:
		  - переделка опций DC, AC, DISTOFx внесла 4 reduce/reduce
		    конфликта:
		    - конфликты возникают при попытке написать правило вида
		      Key ={...} | Key ={...} Value | Key ={...} Value Value
		      при этом YACC не знает, какое из действий "={...}" выполнять
		    - путем ввода правила startVoltCurrOption конфликты устранены

	0.41	  - функция PWL() вносит 4 shift/reduce конфликта, это
		    приводит к тому, что вместо PWL() с 6 параметрами пытается
		    распознать EXP(), поэтому PWL() с 6 параметрами приходится
		    повторно опознавать в правиле для EXP()
		- ElemNLDS /*Bxxx*/
		- в ArExpr внесено правило, описывающее OutVar (внесение самого
		  OutVar вызывает 3 reduce/reduce)
		- в ArExpr убрано правило для открывающей скобки
	?	! если арифметическое выражение с ошибкой, возможно зависание		- OutVar ( заменены на идентификаторы V_SRC, I_SRC)
		- Switch (лексемы ON/OFF/none), для Wxxx сделана
		  обработка ошибки "Параметр voltage должен начинаться с V...",
		  если эту ошибку считать существенной и сбрасывать остаток
		  строки, то это вызывает еще одну (общую) диагностику ошибки
		  для данного оператора
		итог дня:
			106/127 terminals, 202/250 nonterminals
			395/500 grammar rules, 714/1000 states
		!	4 shift/reduce, 3 reduce/reduce conflicts reported

27.01	0.42	обработка ошибки "Параметр voltage должен начинаться с V..."
#28		  для
		  - .DC (DCquad)
		  - ElemLCCCS /*Fxxx*/
		  - ElemLCCVS /*Hxxx*/
		продолжение замены ключевых слов на идентификаторы и переписывание
		  соответствующих правил:
		  - SemiDiode /*Dxxx*/
		  - SemiTransistor /*Qxxx*/
		  - SemiJFET /*Qxxx*/
		  - SemiMESFET /*Zxxx*/                
		  - StmtModel /*.MODEL*/ - косметические изменения
		    продолжение .MODEL на другую строку без '+' теперь вызывает
		      2 rules never reduced (???):
			- maybeModelParameters :  /*nothing*/ ;
			- maybeModelParameters :  ModelParameters ;
		    + 2 shift/reduce conflicts (на этих же правилах)
		    (пока эта возможность отключена)
		  - StmtCtrlLine /*.NODESET*/
		  - StmtCtrlLine /*.IC*/
		  - DECorOCTorLIN
		  - CURorVOL
		  - POLorZERorPZ
		  - StmtCtrlLine /*.NOISE*/

28.01	0.43	продолжение замены ключевых слов на идентификаторы и переписывание
#29		  соответствующих правил:
		  - StmtOutput /*.PRINT*/ - в качестве параметра может быть
		    еще и идентификатор
		  - PrintType : Identifier/*DC/AC/TRAN/NOISE/DISTO*/ + PZ ;
		    если при ошибке в PrintType сбрасывать остаток строки, то
		    возможно зависание, если это был последний перед .end
		    оператор
		замена ключевых слов на идентификаторы завершена, начато
		  тестирование новой версии грамматики на примерах
		- оказалось, что в Vxxx, Ixxx функции PULSE() и другие имеют
		  не строгое кол-во параметров, а от 2-х и более
		  - это добавило 1 reduce/reduce
		  - в IndepSrcFun при неверном имени ф-ции делается SkipRestLine()
		  - обработка PWL() слита с другими функциями - это убрало все
		    конфликты, связанные с данным правилом (4 shf/red, 1 red/red)
	?	- в примерах обнаружилась конструкция .control ... .endc
	?	- возможен такой .PRINT:
			.print onoise.spectrum > spice3.noise.out
		- в .PRINT, .PLOT кроме V(p1[,p2]) возможны (для совместимости со
		  Spice2): VR(), VI(), VM(), VP(), VDB()
		- ошибка в INDUCTCOUPL /*Kxxx*/: замена INDUCTOR на Ident/*Lxxx*/
		! ошибки в CallSubCircuit /*Xxxx*/:
	?	- чтобы убрать 3 reduce/reduce конфликта на правиле CallSubCircuit
		  (netelement "Xxxx"), надо использовать ассоциативность (лучше)
		  или изменять порядок правил (хуже) - так советует документация,
		  но ничего не получилось 
		  - вместо старого не работающего варианта с 3 reduce/reduce:
			CallSubCircuit
			 : SUBCALL SubCallNodeList Identifier
		                ={ Ydebug( "Call subcircuit '%s'", $3 ); }
			   _ENDOFSTMT_
			 ;
			SubCallNodeList : SubCallNode | SubCallNodeList SubCallNode ;
			SubCallNode : Node
		                ={ Ydebug( "... subcircuit node '%s'", $1 ); }
			 ;
		    сделано так:
			CallSubCircuit /*Xxxx*/
			 : SUBCALL SubCallParmList _ENDOFSTMT_ ;
			SubCallParmList
			 : Node /* 'Node' include 'Identifier'
				(subcircuit name - last in list) */
		                ={ Ydebug( "Call subcircuit '%s'", $1 ); }
			 | Node SubCallParmList 
		                ={ Ydebug( "... subcircuit node '%s'", $1 ); }
			 ;
		  - приведенный вариант дает только 1 reduce/reduce и работает
		    без ошибок ! (узлы выводятся в обратном порядке)
		итог дня:
			111/127 terminals, 205/250 nonterminals
			387/500 grammar rules, 698/1000 states
			0 shift/reduce, 1 reduce/reduce conflicts reported
		конфликтные правила:
		  445: reduce/reduce conflict (red'ns 374 and 375 ) on IDENTNAME
		  state 445
			Identifier :  IDENTNAME_    (374)
			Node :  IDENTNAME_    (375)
			,  reduce 375
			.  reduce 374
		- при конфликте по умолчанию будет сворачиваться первое
		  правило - Identifier,
	!?	- остается найти все правила, использующие рядом Identifier
		  и Node

29.01	0.44	попытки устранить последний 1 reduce/reduce конфликт - надо
#30		найти все правила, использующие рядом Identifier и Node:
		- это не CallSubCircuit (netelement "Xxxx")
		- с помощью закомментаривания выяснено, что это кто-то из
		  StmtElement - это SemiTransistor:
		    TRANSISTOR Node/*C*/ Node/*B*/ Node/*E*/           Identifier ...
		    TRANSISTOR Node/*C*/ Node/*B*/ Node/*E*/ Node/*S*/ Identifier ...
	!!??	  - путаницу вносит substrate-узел Node/*S*/, он заменен на
		    bjtSnode, который _не_ может быть идентификатором:
		    bjtSnode/*Node/*S*/ /* only decimal/float, not identifier ! */
		     : IDENTINT     /* decimal number or identifier */
		                        ={ $<strptr>$ = $<mixed>1->text; }
		     | IDENTFLOAT   /* float number or identifier */
		                        ={ $<strptr>$ = $<mixed>1->text; }
		    /*
		     | IDENTNAME
		                        ={ $<strptr>$ = $<strptr>1; }
		    */
		    ;
		- в правиле ArExpr добавлена обработка ошибки (против зависания)
		- проверка на допустимость имен функций в арифметическом выражении
	???	- если в арифметическом выражении встретился _ENDOFSTMT_ (конец
		  строки), это тоже ошибка (в NLDSoption) - обработать пока
		  не удалось - при отсутствии круглой сковки в конце строки
		  происходит:
		  - зависание, если в error-правиле ArExpr делать
		    yyerrok; yyclearin; SkipRestLin();
		  - если делать только yyerrok; yyclearin; то во всех оставшихся
		    до конца файла строках генерируется лавина ошибок о неверном
		    арифметическом выражении
		  + если же ничего не делать, происходит интерпретация следующих
		    строк как продолжения данного выражения до первой требуемой
		    закрывающей скобки, после чего диагностика прекращается
	+	повторное контрольное тестирование на всех примерах

	0.45	собираются воедино:
		- все узлы (имя, тип, элемент, файл:строка),
		  - выдается в статистике количество уникальных узлов
		    и для каждого узла - ссылающиеся на него элементы
		  - сделано с помощью односвязных списков
		  - недостаток: таблица выдается в обратном порядке

30.01	0.46	- выдавать таблицы элементов не в error, а в debug-файл
#31		- первым печатать узел '0' (GND)
		- выдавать элементы в прямом порядке, для чего добавлять элементы
		  в хвост списка с помощью tailNodes, (NodeItem).tailitems
		- добавление счетчика ссылок на каждый узел

31.01	0.47	- возврат к старому правилу для подсхемы (конфликт не возникает -
#32		  причина была другой):
			CallSubCircuit /*Xxxx*/
			 : SUBCALL SubCallNodeList Identifier
		                ={ Ydebug( "Call subcircuit '%s'", $3 ); }
			   _ENDOFSTMT_
			 ;
		- все файлы подписаны
		- при разборе командной строки поднимать регистр флага,
		  а затем сравнивать
		- добавлен флаг '-About' (additional info...)

05.02	0.48	первые шаги по Хабалированию:
#33		- добавлены ключевые слова .HB и .HB_OPTION,
		  /* POLY5(), JUNC() (для Bxxx) - не надо - это делается в
		     ArExpr для Bxxx */
		- в ArExpr добавлены (не дают ошибку) POLY5(), JUNC():
			Bxxx N+ N- POLY5(NC+,NC-,U0,I0,A1,A2,A3,A4,A5)
			Bxxx N+ N- JUNC(NC+,NC-,I0,A)
		- после окончания второго прохода заканчивать *.OBJ-файл Хабалы:
			"
			&VAR fin='End ' /
			&QUP IQ='End ' /
			"
		- флаг '-tFILE' для изменения имени временного файла
		- флаг '-cFILE' для подключения нового конфигурационного файла
		- появился конфигурационный файл "S2HABALA.CNF" (по умолчанию) -
		  искать в PATH или указать флаг '-cFILE'
		- закрывать конфигурационный файл в ShutDown()
		- запоминание стартового имени файла nameFileStart,
		  чтобы после первого прохода снова его открыть и во втором
		  проходе снова вызвать yyparse()
		- для функций обработки параметров созданы SHconfig.C, *.H,
		  внесены в makefile
	?	- запуск yyparse() во втором проходе пока работает неверно,
		  несмотря на то, что перед этим:
		    /* reopen start input file: */
		    CloseInput();
		    if( !OpenInput( nameFileStart ) )
		        MsgErrorFatal( exitERRINPREOPN, msgERRINPREOPN, nameFileNew );
		    ptrStack = NULL;  /* free stack of files */
		    cntInclNest = 0;  /* counter of include files nesting */
		    /* initial settings: */
		    yyTokenPos = 0;
		    yyTokenLine/*yylineno*/ = 0;
		    is1stline = TRUE; /* say to Lex about 1st line of file is title */
		  (первая строка файла обрабатывается не как титульная)

06.02	0.49	- SHlpars.L:
#34		  - доработки, связанные с перезапуском на второй проход:
		    is1stline, ptrStack, cntInclNest стали глобальными
		  - в yylex() еще до начала обработки правил: если есть признак
		    титульности первой строки, производится сброс до конца строки
		    и возврат _ENDOFSTMT_
		  - чтобы на втором проходе первая строка правильно обрабатывалась
		    как титул пришлось в SHmain.C делать:
			yyTokenLine/*yylineno*/ = 1;
			SkipLines( fileInp , yyTokenLine/*yylineno*/ );
		  - распознавание /*...*/ комментария (как в C)
	!?	? при повторном запуске Lex на втором проходе под те же
		  стороки, элементы, идентификаторы, идентификаторы-числа
		  снова выделяется динамическая память !
	!!?	- проверка освобождения памяти в PopFileStack() показала,
		  что используемый компилятор сборку мусора не производит,
		  поэтому делать free(...) бесполезно
		- конфигурационный файл при запуске анализируется, заполняя
		  массив параметров: AnalyseConfFile() и др.
		- изменение отдельного параметра: ChangeConfOption()
		- борьба с синтаксическими ошибками в конфигурационном файле
		  (разбор производится вручную)
		- в грамматике добавить правила с .HB и .HB_OPTIONS, при
		  появлении соответствующих директив в исходном тексте
		  изменять соответствующий элемент в массиве параметров:
		  ChangeConfOption(...)
	?	? может ли один и тот же параметр изменяться несколько раз ?
		- Pass2() запускается только если в первом проходе не обнаружено
		  ошибок, иначе генерация кода для ошибочного оператора может
		  иметь незаконченный вид
		- сделана генерация кода для .HB-оператора
	!!?	- глюк этого компилера (а может так и надо ?): каждый второй
		  элемент .HB-пары обнулялся:
		  - причиной был вывод long-числа с форматом '%d' вместо '%ld'
		    (причем первое long-число выводится правильно, а второе -
		    нет - надо помнить об этой особенности компилятора !!!)

07.02	0.50	- SHpass1:AddNodeInfo(): на втором проходе уже ничего в таблицы
#35		  не вносить
		- запоминать перед началом первого прохода содержимое титульной строки
		  до 60 символов: SHconfig:SaveTitul();
		- разные опции предназначены для разных целей, поэтому в таблицу
		  опций добавлено поле isserv для обозначения опций директивы
		  &SERVIS
		- генерация в конце первого прохода в начале *.obj хабала-директивы
		  &SERVIS ...=... , ...=... , ... , NAME='...' /
		  где NAME - первые 60 символов титульной строки или имя
		  стартового файла без расширения, если титул пуст: OutHabSERVIS()
		- добавить новое char[4]+'\0'-имя узла, в конце первого прохода
		  переименоввывать узлы: имя - 4-байта - целое число с пробелами,
		  начиная с '0   '(GND))

08.02	0.51	- в информации о разработчике добавлены электронные адреса
#36		  spice3man@yahoo.com, spice3man@mail.ru
		- функция GetConfOption( name, &dblval, &longval )
		- функция strEQ(str1,str2), проверяющая совпадение строк,
		  игнорируя регистр, но без strupr(str), которая портит строку
		- streq() заменена на strEQ():
		  - в Lookup...() в *.Y *.L, SHconfig.C - при сравнении опций
		- SHpass1.c: сборка на первом проходе информации о количестве
		  и именах элементов, помещая их в списки:
		  - элемент списка содержит:
		    - spice-имя (как в оригинале)
		    - 4-символьное хабала-имя
		    - имя файла и номер строки
		    - (и пока все !)
		  - указатели на головы списков и счетчики для разных типов
		    элементов - разные
		  - указателей на хвост - нет - элементы в списке будут в
		    обратном порядке
		  - функции добавления имен в список, функции переименования -
		    общие: AddElem(list, *cnt, name), RenameElems(list)(еще нет),
		    PrintElemList(listElem, cnt, type), FindElem(listElem, elemname)
		  - сразу после занесения spice-имени в 4-байтное поле хабала-
		    имени заносится его усеченный вариант, причем первая буква
		    (обозначающая тип) - большая
		  - SHpars.Y: для пробы сделан сбор элементов для индуктивностей
		    listL = AddElem( listL, &cntL, $1 );

09.02	0.52	  - проба показала, что вносить элемент в список надо только
#37		    тогда, когда весь его оператор опознан YACCом, т.е. в конце
		    правила перед _ENDOFSTMT_, иначе в списке оказываются и
		    ошибочно описанные элементы, но при этом:
		  - следить за номером позиции: если он = 0, то произошел
		    переход на новую строку
	!?	  ? spice-имена, набранные в разных регистрах, отличаются,
		    если отличается регистр только первой буквы (L2 и l2),
		    то на первом этапе генерации хабала-имени у них будут
		    совпадающие имена (L2 и L2), а на следующем этапе одному из
		    них будет присвоено другое имя (L2 и L999),
		  - SHpass1.C:HabTYPout() сразу после первого прохода выдаются
		    операторы &TYP с количеством элементов каждого типа,
		    сделано для:
		    - L
		    - R, SHpars.Y: listR = AddElem( listR, &cntR, $1 ); но только
			 для обычных, а не полупроводниковых резисторов
		    - C, SHpars.Y: listC = AddElem( listC, &cntC, $1 ); но только
			 для обычных, а не полупроводниковых конденсаторов
		  - RenameElems(list):
		    после сбора всех элементов одного типа запускается функция
		    переименования RenameElems(list), по порядку проверяющая,
		    есть для данного усеченного имени в списке _за_ним_ хоть
		    одно совпадающее,
		    если находится, то элемент переименовывается в Xnnn, где
		    X - первая буква имени, определяющая тип, nnn - номер из
		    набора 999..001 (элементы в списке - в обратном порядке -
		    запутаем врагов), проверяя чтобы и для Xnnn не было совпадения
                    (проверено на ADC.SPI - там куча резисторов RLUMPnnn)
		- SHpass1.C: для второго прохода подготовлены функции:
		  - GetHabNodeName(spicename), возвращающая по spice-имени
		    узла его 4-байтное имя
		  - GetHabElemName(list, spicename), возвращающая по spice-имени
		    элемента его 4-байтное имя
		  - HabELEMout() - генератор директивы &ELEM в общем виде
		- SHpass2.C:ftoa() - преобразование double в строку, место под
		    строку выделяется динамически
		- SHlpars.Y:
		  - генерация хабала-кода (&ELEM) производится на втором проходе,
		    где для конкретного элемента подставляется его новое
		    хабала-имя и переименованные в числа узлы, информация
		    из spice-оператора и конфигурационные параметры
		  - пробная генерация кода (&ELEM) для индуктивностей(L)
                - SHpass2:HabFinishElems(): завершение секции описания элементов

10.02	0.53    введен признак isSubCktDefBody, чтобы при входе в описание
#38		  подцепи (isSubCktDefBody := TRUE) и не обрабатывать узлы
		  и элементы, вызовы подцепей пока будут игнорироваться:
		- AddNodeInfo() если isSubCktDefBody == TRUE сразу прекращается,
		  возвращая -1, в будущем - будет заносить узлы в локальный для
		  подцепи список узлов
		- при сборе элементов в список перед AddElem() и перед генерацией
		  кода также делается проверка if( !isSubCktDefBody )
		- переименованы счетчик узлов главной программы и указатели на
		  список этих узлов:
			cntNodes  -> cntNodesMain
			listNodes -> listNodesMain
			tailNodes -> tailNodesMain
		- SHpass1.C: следующие функции должны иметь параметром список
		  узлов вместо listNodesMain по умолчанию и вызываться
		  соответствующим образом (пока с listNodesMain) - подготовка к
		  обработке узлов подсхем:
		  - FindNode(*list, ...)
		  - RenameNodes(*list)
		  - PrintNodesList(*list)
		  - CreateNode(**list, **tail, *cnt, ...)
		  - GetHabNodeName(*list, ...)
		  - AddNodeInfo(**list, **tail, *cnt, ...)
		    - SHpars.Y:
		      - вызовы AddNodeInfo() делать через вызовы макроса:
			#define ADD_NODE_MAIN( name, type, elem )	\
			  if( AddNodeInfo( listNodesMain, tailNodesMain,\
			      &cntNodesMain, name, type, elem ) == NULL	\
			    ) MsgErrorFatal( exitFAILPASS1, msgFAILADDNODE )
			(а то слишком длинная строка):
		      + проверка, не узел ли это подсхемы
			if( !isSubCktDefBody ) ADD_NODE_MAIN( name, type, elem );

11.02	0.54	- добавлен флаг -k - keet temporary files for debugging
#39	        - nameDirTmp[maxFNAMELEN];/*temporary directory*/ - по ум. "."
		- удалять временные файлы - используя счетчик:
		  for( i=0; i<cntTmpFiles; i++ ){
		    GetTmpFileName( nameFileTmp, nameTMPMASK, cntTmpFiles++ );
		    remove( nameFileTmp );
		  }
		- cntTmpFiles - счетчик для генерации временных файлов;
		- так как временных файлов будет много, сделать генератор
		  имен временных файлов GenTmpFileName(), используя глобальный
		  счетчик cntTmpFiles и прототип имени, например, "S2H_%04d.TMP":
		  GetTmpFileName( nameFileTmp, nameTMPMASK, cntTmpFiles++ ):
		  { sprintf(nameFileTmp,nameTMPMASK/*прототип*/,cntTmpFiles); }
		- первым открываемым при запуске и всегда обязательным будет
		  временный файл номер 0 "S2H_0000.TMP" - в нем будут собираться
		  все генерируемые элементы (в том числе и для подсхем) перед
		  сортировкой
		- флаг -tTEMP_FILE заменить на -tTEMP_DIR (по умолчанию - ".")
		  и временные файлы:
		  - открывать в этом каталоге
		  - удалять в нем
		- fileInc, nameFileInc /* temporary file for make include subcircuit */
		! запись в конце первого прохода в *.OBJ-файл Хабала-директив
		  о количестве элементов - сразу нельзя, надо для хабалы
		  давать вначале количество элементов одного типа, потом
		  строки с их описанием, потом то же для нового типа и т.д.
		- директивы элементов надо записывать во временный файл, а на
		  этапе окончательной сборки сортировать по типам и выдавать
		  на выход однотипными группами
		- из-за наличия подсхем общее количество элементов в первом
		  проходе вычислить нельзя, вероятно прийдется нагенерировать
		  все элементы во временный файл, а там уже их подсчитывать,
		  а подсчитав выдать директиву
			"&TYP ... KOL=кол-во"
		  а после нее все элементы только этого типа
		- перечень элементов должен заканчиваться
			"
			&TYP  IT='End ' /
			"

12.02	0.55	- для вывода (непредсказуемо) длинных строк в результирующий файл
#40		  сделана функция Out80(), аналогичная Out(), только при выводе
		  разбивающая строку на части меньше 80 символов в местах, где
		  встретились {' ', ',', '='}
		- директива &FREQ выводится _после_ списка элементов
		- весь вывод хабалы делится на 4 части:
		    HabElemPart();  /* Elements part */
		    HabFreqPart();  /* Frequency part */
		    HabVarPart();   /* Variations part */
		    HabQuaPart();   /* Quality parameters part */
		- введены (глобальные) счетчики переименований (999...000) для
		  каждого типа элементов, чтобы при генерации подцепей
		  (обязательно) переименовывать не повторяясь каждой вхождение
		  подцепи
		- при исчерпаннии счетчика переименований элементов одного типа
		  происходит фатальная ошибка, приводящая к прерыванию программы
		- начало создания списка подцепей SubCkt, содержащего:
		  - имя подцепи
		  ! указатель на локальный список узлов
		  - где начинается (файл, строка)
		  - где заканчивается (файл, строка),
	!!	SHcommon.H:
		  # include   "SHpass1.H" - должно быть раньше, чем
		  # include   "SHpars.H"
		    (так как в SHpass1.H определяются типы-структуры,
		    используемые в SHpars.*)
		- SHpass1.C: создан стек вложенных подсхем и функции:
			PushCircStack()
			PopCircStack()

13.02	0.56	- в разделе статистики выдаваются сведения о количестве
#41		  _определений_ элементов
		- проба перехода на другой компилятор BC31
		  (из-за "Out of memory" у TC2)
	!	- для совместимости разных версий компиляторов: в *.H-файлах
		  при описании прототипа функции без параметров надо писать
		  func( void );

16.02	0.57	SHpass1.C: + функции
#42		  AddSubCkt(list,имя)    + начало_файл:строка
		  AddSubCktEnd(list,имя) + конец_файл:строка
		  FindSubCkt(list,имя)
		  CreateSubCkt(list,имя)
		  PrintSubCktList(list)
		- указатель circCurrent устанавливается при входе в тело
		  определения подсхемы и обNULLяется при достижении ее конца -
		  .ENDS, точнее, в случае вложенных подсхем - берется из стека
		  подсхем
	!	- в списке элементов добавлен признак, к какой подсхеме
		  относится (указатель на элемент из списка подсхем)
		- и заностся его значение при внесении элемента в список
		- и в отладочной печати списка элементов указывается подсхема
	!	- при занесении в таблицу элементов: совпадать имена
		  будут только в том случае, если совпадают также имена
		  их подсхем - это надо учесть:
		  - при поиске элементов
		  - при выдаче диагностики "Элемент с таким именем уже есть"
		SHpass1.C:
		- переделка AddNodeInfo(), чтобы по ссылке передавался
		  только счетчик узлов, возвращался указатель на хвост,
		  а указатель на начало ведь не меняется!
		- а также CreateNode()
		SHpars.Y: переделка
		- #define ADD_NODE_MAIN( name, type, elem )
		- #define ADD_NODE_SUBCIRC( name, type, elem )
	??!	несмотря на переделку компилятор TC2 говорит "Out of memory" !
	!!!	приходится перейти на BC++3.1

18.02	0.58	после переделки AddNodeInfo() и CreateNode():
#43		- список узлов не печатается
		- неверно генерируются узлы в &ELEM: KNOT=(null)
		! причина в том, что самый первый раз указатель на голову списка
		  = NULL, а функция никак не может его вернуть (после переделки)
		поэтому функции AddNodeInfo() и CreateNode() снова изменяются:
		- введены глобальные временные переменные listNodesTmp
		  и cntNodesTmp, которые модифицируются внутри CreateNode()
		- счетчик узлов передается по значению (чтобы вернуться к TC20 -
		  не помогло)
		- изменены вызовы AddNodeInfo() в SHpars.Y в макросах 
		  ADD_NODE_MAIN и ADD_NODE_SUBCIRC
		SHpars.Y, SHpass1.C: (кроме списка узлов элементов для подсхемы)
		- занесение списка локальных узлов при вхождении в описание
		  подсхемы на первом проходе
		- ADD_NODE_SUBCIRCPARM
		Кстати, о парсере:
		  113/127 terminals, 224/250(200) nonterminals
		  416/500(400) grammar rules, 747/1000(600) states
		  0 shift/reduce, 0 reduce/reduce conflicts reported
		  224/250 working sets used
		  memory: states,etc. 3590/5200, parser 748/4000
		  (стандартные лимиты превышены)
		не работало занесение в подсхемы узлов-параметров и локальных
		  узлов элементов в макросах ADD_NODE_SUBCIRC(PARM), где в
		  качестве указателей на начало/конец списка узлов используются
		  указатели из circCurrent:
		  - оказалось, что в AddNodeInfo() стояла заглушка
		введен тип узла nodtypUNKNOWN вместо NULL, чтобы не вносить
		  путаницу

19.02	0.59	&SERVIS -> &SERV
#44		добавлено ADD_NODE_SUBCIRC при обработке узлов для всех элементов
		  (для C, L, R - уже было сделано)
	?	не всегда печетается отладочный список узлов-параметров и
		  локальных узлов для подцепей:
		- причина в том, что PrintNodesList() вначале искала узел 0,
		  а _после_ того как находила, печатала остальное
		если оператор .HB встречается больше 1 раза - диагностика
		  ошибки и не обрабатывать
		открывать и заполнять по мере генерации кода файл соответствия
		  узлов Spice<->Habala S2HNODES.TMP:
		- закрывать его в ShutDown()
		- флаг -nFILE_NODE - указание имени файла трансляции узлов
		- ф-ция OutNodeTr()
		- в конце первого прохода: PrintNodesTransl( глав_схема, список );
		введен признак levelSubCall:
		  = 0 для главной схемы
		  ++1 при каждом вызове
		- введен признак isSubCall, который будет устанавливаться
		  перед вставкой временного файла с телом подсхемы, а при выходе
		  из вставляемого файла (в *.L):
		    if(isSubCall) levelSubCall--;
		    if(levelSubCall==0) isSubCall = FALSE;
		итог дня: общая сумма строк исходников проекта перевалила
		  за 7000, данный файл протокола работ - 1500 строк

20.02	0.60	*.L: все действия при вставке .include-файла вынесены в отдельную
#45		  процедуру IncludeFile(имя)
		SHiofun.C: OutInc() - вывод во временный файл с телом подсхемы
		SHpass2.C: MakeCircBody( SubCirc *circCall )
		*.Y: везде circCurrent -> circDefCurrent, чтобы подчеркнуть, что
		  идет речь о вхождении распознавателя в описание подцепи на
		  первом проходе, генерироваться код должен только при условии
			if( PassNo == 2 && circDefCurrent == NULL )
		  т.е. при вхождении в определение подцепи ничего генерироваться
		  не должно, зато при вызове подсхемы в элементе Xxxx:
		  - isSubCall := TRUE
		  - levelSubCall++
		  - делается копия тела нужной подсхемы во временный файл с
		    помощью MakeCircBody(схема)
		  - временный файл включается как .include-файл на месте
		    элемента Xxxx
	!	  - при этом может быть circDefCurrent != NULL, так как внутри
		    вызова может также встречаться описание подсхемы,
		    признак circDefCurrent != NULL должен использоваться для
		    индикации того, что генерация кода не должна проводиться
		к именам временных файлов с телом подсхемы добавляется путь
		  nameTmpDir
	?	происходит попытка считывания после конца включаемого файла
		  с телом подсхемы в PrintLine() - закомментарен MsgErrorFatal()
	???	пока работает плохо - не все подсхемы разворачиваются

21.02	0.61	SHiofun.C: везде при генерации кода 'End ' -> 'END '
#46		SHpass2.C: в отладочных целях в PrintLine() разкомментарен
		  MsgErrorFatal()
		перед вызовом тела подсхемы проверяется, принадлежит ли вызываемая
		  подсхема данной схеме
		после второго прохода также выдавать количество ошибок:
		  оно будет равно общему количеству ошибок, так как на второй
		  проход пускаем только если на первом проходе ошибок нет
		обнаружено, что при замене оператора "Xxxx ... схема"
		  на include-файл с телом соответствующей схемы в буфере Lex'а
		  остается один символ - первый символ следующей за оператором
		  "Xxxx ... схема" строки
		  - этот символ сбрасывается в IncludeFile() при условии
		    if( isSubCall && levelSubCall > 0 )
        !?!	    - это может стать источником ошибок в будущем
		SHiofun.C: в MsgCompile(), MsgErrorFatal() добавлено дублирование
		  описания ошибки в debug-файл в отладочном режиме
		итак, сбои продолжаются: Lex ошибочно позиционируется при
		  окончании обработки подсхемы-include-файла, заставляя
		  PrintLine() пытаться читать после конца файла, что вызывает
		  ошибку "*FATAL* Read error on input file", но если игнорировать
		  эту попытку, то вроде как-то дышит
	???	теперь при возврате из вызова подсхемы пропадает следующая за
		  обработанным оператором Xxxx сторока:
		- устранилось добавлением в ReturnPrevFile():
	          if( isSubCall && levelSubCall > 0 ) lno--;
        !?!	    - это может стать источником ошибок в будущем
		удивительно, но вроде заработало, причем вроде обработка
		  нормальных include-файлов не нарушена !
		SHlpars.L: теперь надо скрыть диагностику о включаемых временных
		  файлах (т.е. когда isSubCall == TRUE):
		- в ShowLine()
		- в IncludeFile()
		- в ReturnPrevFile()
		в отладочных командных файлах перед запуском удалять временные
		  файлы S2H?????.tmp

23.02	0.62	AddSubCirc(): добавлена проверка наличия подсхемы с совпадающим
#47		  именем в списке подсхем
                в MsgCompile() при диагностике ошибки в _конце_ строки курсор
		  неверно показывает позицию в строках с табуляцией, так как
		  неверно возвращается len = PrintLine() - переделан подсчен
		  len в PrintLine()
		переменную isSubCktDefBody решено оставить, переименовав ее
		  в isSubDefBody и сделав глобальной, чтобы служила признаком
		  того, что код генерировать не надо
		в *.Y обработку конца схемы с занесением файла:строки
		  перенесено до момента распознавания .ends, иначе до занесения
		  файла:строки конца схемы производится PopFileStack(), сбивая
		  нумерацию
		итог: если входной файл единый все как-то работает,
	???	  а если подсхема лежит в include-файле, сбивается нумерация
		  строк, а вместе с ней и генерация временных файлов, содержащих
		  тела подсхем, и диагностика ошибок указывает не ту строку

29.02	0.63	переход на Visual C++ 4.0:
#48		- полностью переделаны make-файлы
		- нет <dir.h> с функцией searchpath() - используется для поиска
		  конфигурационного файла *.CNF в %PATH%, можно опустить
		- нет coreleft() - для индикации оставшейся динамической памяти
		  в отладочном режиме, можно опустить
		- теперь компилируется и под Borland C++ 3.1 (как DOS-программа),
		  и под Visual C++ 4.0 (как консольная Win32-программа)
	!	написан макрос yySkipUnput (сброс unput()-буфера) на основе
		  анализа Lex-текстов - может быть на переносим !

01.03	0.64	переписана обработка include-файлов, используя макрос yySkipUnput
#49		  вместо глупых комбинаций input() и unput()
	?	иногда на консоль выводится информация о включаемом временном
		  файле-схеме:
		  Line     8  (.\S2H_0001.TMP)

03.03	0.65	появилась новая порция примеров из интернета (ckt.zip)
#50		  (формальные спецификации на Spice3 не найдены)
		  при проверке не прошли примеры из-за ошибок:
		- ff.ckt	- из-за подсхем (исправление отложено)
		- tr2.ckt	- Illegal keyword '.OPTION' вместо '.OPTIONS'
					- добавлен вариант ключевого слова
		- mem2.ckt	- ошибка в .TRAN: в конце стоит UIC
					- добавлена опция UIC в .TRAN
		- dc5,dc6.ckt	- в .DC: четверка параметров может начинаться
				  не только с V..., но и с I... - доделано
		- opa4.ckt	- в .TRAN: в конце стоит UIC - исправлено
		  (это не все)
		попутно исправлена ошибка при дублировании MsgCompile() в
		  debug-файл - опять глюки Borlanda
	!!!	таким образом, обнаружены новые конструкции:
		- .control ... .endc
	!?	- "let ...=..." - это не индуктивность, если эта конструкция
		  находится внутри .control ... .endc
	?	- 'alter', 'write' - тоже внутри .control ... .endc и без точек
	???	сюрпризы:
		- управляющие операторы, заключенные в .control ... .endc
		  могут не начинаться с точки - здесь такого нельзя !
		- неверно разбирается арифметические выражения
		итог изменений в грамматике:
		  118/127 terminals, 230/250 nonterminals
		  428/500 grammar rules, 765/1000 states
		  0 shift/reduce, 0 reduce/reduce conflicts reported
		  230/250 working sets used
		  memory: states,etc. 3674/5200, parser 771/4000

04.03	0.66	добавлена конструкция .let Identifier = ArExpr
#51	?	для .alter и .write добавлены заглушки, генерирующие ошибку
		  и предупреждение (из-за неопределенного синтаксиса этих
		  конструкций)
		итог:
		  118/127 terminals, 234/250 nonterminals
		  436/500 grammar rules, 782/1000 states
		  0 shift/reduce, 0 reduce/reduce conflicts reported
		  234/250 working sets used
		  memory: states,etc. 3754/5200, parser 793/4000
		при проверке не прошли примеры из-за ошибок:
		- opa4.ckt	- в арифметических выражениях в элементах Bxxx:
				  (ABS(V(1,2)+80M) - не работает (+/- число
				    перед ')', только для +/-!)
				  (80M+ABS(V(1,2)) - работает нормально
				  - причина: Lex приклеивает +/- к числу -
				    исправить, а в *.Y изменить правила:
				    Value : '+'/'-' UnsignValue ={$$ = -$2;}
				    DecIntNum : '+'/'-' UnsignDecIntNum ={$$ = -$2;}
				    FloatNum  : '+'/'-' UnsignFloatNum  ={$$ = -$2;}
	!	  - теперь Lex будет возвращать числа без знаков, исправлены:
			DECIMAL_NUM [-+][0-9]+
			  - исчезло вместе с правилом
			  <CODE>{DECIMAL_NUM}({SCALESUFX})? { /* decimal num */
			  - осталось только DECIMAL_ID
			FLOAT1S     [-+][0-9]+"."[0-9]*([eE][-+]?[0-9]+)?
			FLOAT2S     [-+]?[0-9]+"."[0-9]*[eE][-+][0-9]+
			FLOAT3S     [-+][0-9]+[eE][-+]?[0-9]+
			FLOAT4S     [-+]?[0-9]+[eE][-+][0-9]+
			FLOAT1E     [-+]?[0-9]+"."[0-9]*[eE][-+]?[0-9]+
			FLOAT2E     [-+]?[0-9]+[eE][-+]?[0-9]+
			FLOAT1P     [-+]?"."[0-9]+([eE][-+]?[0-9]+)?
		    а в грамматика дополнительно появятся конструкции
			UnsignDecIntNum, UnsignFloatNum (для ArExpr) - они
			заменят старые
		из-за того, что в VisualC++ уже используется макроопределение
		  _CONTROL, оно переименовано в _CONTROLS
		итог:
		  118/127 terminals, 237/250 nonterminals
		  445/500 grammar rules, 797/1000 states
		  0 shift/reduce, 0 reduce/reduce conflicts reported
		  237/250 working sets used
		  memory: states,etc. 3821/5200, parser 862/4000
	?	осталось разобраться с примерами (ckt.zip):
		- d2.ckt	- Illegal keyword '.control'
				- и еще 'alter', 'write' - добавлены как ключевые
				  слова с точкой вначале
		- v1.ckt	- Illegal keyword '.control'
				? непонятная конструкция dc vin 0 1 0.2
					- вероятно надо .dc vin 0 1 0.2
				- ключевые слова .save и .print без точек впереди
				- в конструкции .print встретились:
				  - недопустимый символ @ в начале параметра
				  - V()
		- r1.ckt	- Illegal keyword '.control'
				- в SAVE недопустимый символ @ в начале параметра
				- обнаружена новая конструкция let Id=ArExpr
				  (принята за индуктивность) - добавлено ключевое
				  слово .LET
		- ff.ckt	- имя подсхемы может начинаться с цифры

	0.67	подготовка к отказу от обработки вызовов подсхем через временные
		  файлы:
		- при занесении в список информация о подсхеме должна указывать
		  на начало - строку с .subckt, конец - строка с .ends включительно
		- в стек файлов функциями Push/PopFileStack() заносятся и
		  восстанавливаются еще 4 элемента (см.ниже)
		  (пока это привело к зацикливанию)
		- для окончания схемы будет использоваться ReturnPrevFile(),
		  которая сделана глобальной
		- в функции IncludeFile() появился 2-й параметр - номер строки,
		  с которой начинать
		  - производится соответствующий сброс строк с помощью SkipLines()
	!	отказ от обработки вызовов подсхем через временные файлы:
		- теперь не надо бороться с диагностикой типа
		    Line     8  (.\S2H_0001.TMP)
		- (pass2) теперь при достижении элемента Xxxx (вызова подсхемы) будет
		  заносится состояния в стек (для Lex-include):
		  - isSubCall
		  - levelSubCall
		  - isSubDefBody
		  - указатель на подсхему circCall
		- (pass2) устанавливаться:
		  isSubCall = TRUE;
		  levelSubCall++;
		  isSubDefBody = FALSE;
		  circCall = ...
		- (pass2)  с помощью отработанного уже include-механизма осуществляться
		  скачек на файл circCall->begfname, строку circCall->begline,
		  попадая при этом на оператор .subckt ...
		- (pass2) внутри схемы:
		  - if(isSubCall) then производится генерация кода
	!	  - при достижении .subckt: isSubDefBody:=TRUE и все что идет
		    дальше вплоть до .ends должно игнорироваться, в том числе
		    и вызовы Xxxx - if(isSubDefBody) !
		  - при попадании Xxxx производится рекурсивный вызов подсхемы
		    (как описано с начала)
	?	- (pass2) при достижении парного .ends (? или лучше при достижении
		  circCall->endline) из стека должны быть восстановлены
		  - isSubCall
		  - levelSubCall
		  - isSubDefBody
		  - указатель на подсхему circCall
		  и произведен возврат на следующую за Xxxx инструкцию
		! ReturnPrevFile(): при выходе из (любого) .INCLUDE-файла проверять:
		    if(isSubCall) levelSubCall--;
		    if(levelSubCall==0) isSubCall = FALSE;
		- теперь уже не нужны функции:
		  - MakeCircBody() в фрагменте вызова Xxxx в *.Y:
                       /* make new temporary file with subcircuit body: */
                       name = MakeCircBody( circCall );

                       /* prepare full tmp-file name = path + file name: */
                       for( i = 0; i < maxINPLINELEN; i++ ) fullname[i] = 0;
                       strcpy( fullname, nameDirTmp );
                       strcat( fullname, sPATHSEPARATOR );
                       strcat( fullname, name ); /* make full file name with path */
		  - PushCircStack( circDefCurrent ); в .SUBCKT
		  - circDefCurrent = PopCircStack(); в .SUBCKT 
	?	итог дня: программа на одном и том же входном файлом с подсхемами
		  то циклит, то нет !?8-) - пора спать !

05.03	0.68	в зависимости от того, какой компилятор установлен, mk.bat
#52		  строит либо DOS, либо Win32 приложение с учетом особенностей
		  (для UNIX не сделано в связи с отсутствием платформы)
		отладка вызовов подцепей и другое:
		- если Borland циклит, то Visual падает
		- ff.ckt: имя подсхемы может начинаться с цифры - исправлено:
		  _SUBCKT Identifier	-> _SUBCKT Node/*Identifier*/
		  _ENDS Identifier	-> _ENDS Node/*Identifier*/
		  SUBCALL SubCallNodeList Node/*Identifier*/

07.03	0.69	программа возвращает exit-коды:
#53		=0 - все OK
		<0 - fatal error
		>0 - количество ошибок
		изменен формат файла трансляции узлов:
		- habala \t spice \t full_circ_name
		SHiofun.C:OutFile() - вывод в любой файл
		фрагмент:
                     /* for subcall processing: */ /*ASB000219*/
                     if( isSubCall ) levelSubCall--;
                     if( levelSubCall == 0 ) isSubCall = FALSE;
		  перенесен из *.L:ReturnPrevFile() в обработку .ENDS в *.Y
		переименование элементов производится с 001 до 999, а не наоборот
		добавлен файл переименования элементов:
		- ключ -mELEMFILE для указания имени файла переименования элементов
		- fileElem, nameFileElem
		- SHiofun.C:OutElem()
		- при выводе информации об элементе в файл S2H_0000.tmp
		  выдавать в файл S2HELEMS.tmp информацию об изменении его имени
		  и схеме, в которой он встретился (как в S2HNODES.tmp)
		  - PrintElemsTransl(имя, цепь, список_элементов)
		  - вставить PrintElemsTransl() в *.Y после HabELEMout()
		GetHabElemName() - работает неправильно, если ищется элемент не
		  главной подцепи - введен параметр-цепь:
		- GetHabElemName(имя, цепь, список_элементов)
		- исправлены вызовы GetHabElemName() в *.Y

09.03	0.70	в отладочных *.BAT-файлах добавлен вывод errorlevel
#54		- кстати, errorlevel лежит в пределах 0..255, и если программа
		  возвращает отрицательный код, то он лежит в пределах 128..255
		- поэтому при превышении количества ошибок в тексте программы
		  числа 127 надо его усекать
		в стек файлов добавлен еще указатель на circDefCurrent, который
		  сохраняется/восстанавливается в Pop/PushFileStack()
		признаком генерации кода при вызове подсхемы является
		  if( isSubCall && ( circCall == circDefCurrent ) )
		  в общем случае:
                  if( !isSubDefBody ||
                       isSubDefBody && isSubCall && (circCall == circDefCurrent) )
		пока циклит при наличии вложенных подцепей

11.03	0.71	выделены в отдельный файл SHexcode.H коды возврата,
#55		- переделаны 2 makefile (для BC++ и VC++)
		- коды ошибок откомментарены
		выдавать полное имя подцепи: /подцепь/подцепь/.../подцепь
		  (функция OutFullCircName(выхфайл,указатель) - рекурсивная!)
		обработка подцепей все еще не работает:
		- сделан отладочный макрос SHOWCIRCSTATE

12.03	0.72	отладка работы вызовов подцепей:
#56		- OutFullCircName() сделана нерекурсивной,
		  выдает ошибку если длина полного имени слишком большая
		  (рекурсивный вариант также оставлен)
		*.Y в обработке .subckt введен levelSubDef, который:
		  - levelSubDef++; при входе в подсхему
		  - при выходе
		    levelSubDef--;
                    if( levelSubDef == 0 ) isSubDefBody = FALSE;
		  - печатается отладочным макросом SHOWCIRCSTATE
		  - также заносится в стек
		снова неверно заносится в местонахождение конца схемы:
		- причина - после .subckt изменяется circDefCurrent, поэтому
                  в начале обработки .ends:
		    circDefCurrent = circDefCurrent->parent;
		  тогда не надо "->parent"
                     AddSubCircEnd( listSubCirc, circDefCurrent/*->parent*/, $2 );
		первый проход вроде работает корректно

14.03	0.73	печать в списках элементов полного имени подцепи
#57		при генерации кода должен соблюдаться баланс .subckt-.ends,
		  иначе будет неверно производиться выход из подсхем и
		  восстановление состояний, поэтому при нарушении баланса
		  до второго прохода не должно доходить - *.Y:
		- добавение 'error' в правило
			ENDSubCircuit
			 : _ENDS _ENDOFSTMT_
			 | _ENDS Node/*Identifier*/ _ENDOFSTMT_
			 ;
		  приводит к конфликту - все равно распознаватель не знает
		  (и никто не знает) места, где, например, потерялся .ends,
		  поэтому решено на первом проходе подсчитывать количество
		  ".subckt" и ".ends", и при их несовпадении выдавать в конце
		  файла ошибку, что будет препятствовать переходу на второй
		  проход
		- также сделан счетчик и для .END - если он не = 1 в конце - это
		  тоже ошибка: CheckCircBrackets()
		MsgErrorFatal(): сообщение дублируется и в fileErr

18.03	0.74	продолжение отладки работы вызовов подцепей:
#58		  состояние подсхемы должно восстанавливаться только при выходе
		  из подсхемы, а не из include-файла, поэтому сделан
		  перенос из стека файлов состояний схемы в свой стек:
		- из структуры SHlpars.C:StackFiles в SHpass1.C:StackCirc
		- PushCircStack(/* *circ */);
		- SubCirc *PopCircStack();
		- вызов PushCircStack() при входе в .subckt
		- вызов PopCircStack() при выходе (.ends)
		- изменилась логика обработки состояний подцепи при входе/выходе
		  в определение подцепи на разных проходах, логику вызова:
		  состояние запоминается/восстанавливается только во 2 проходе:
		  - при входе в описание схемы/выходе из него
		  - при вызове тоже заталкивать состояние в стек,
		    а вот вынимать это состояние из стека надо после возврата
		    из .ends (повторно после уже выполненного выталкивание)
		    при выполнении того же условия, при готором начиналась
		    генерация:
                    if( !isSubDefBody ||
                         isSubDefBody && isSubCall && (circCall == circDefCurrent)
		  - в стеке запоминаются только указатели на схемы,
		    остальное - лишнее

19.03	0.75	продолжение отладки работы вызовов подцепей:
#59		- похоже, что неверно работает функция (не туда переходит)
		  IncludeFile( circThis->begfname, circThis->begline );
		  - неверно устанавливался yylineno
		- добавлен yySkipUnput; в начало второго прохода вместо
		  SkipLines( fileInp, yyTokenLine/*yylineno*/ - 1 );
		- ошибка при занесении последнего номера строки схемы при
		  обнаружении .ends на первом проходе - неверно устанавливается
		  circDefCurrent - заносить в стек состояний надо и на
		  первом тоже!

20.03	0.76	maxERRCOUNT перенесено в SHexcode.H, который будет служить для
#60		  связи с разработчиком интерфейса
		пришли требования новых косметических изменений от заказчика:
		1)Директива ".HB" может быть не единственной в файле. Каждая
		  последующая полностью переопределяет предыдущую
		  - в v.0.59/19.02 директива .HB была сделана единственной
		    по требованию заказчика - для каждой .HB-директивы
		    генерировался код во временный файл, но при появлении
		    больше одной .HB выдавалась ошибка первого прохода и
		    генерация кода не проводилась
		  - теперь на втором проходе из временного файла надо взять
		    только последнюю &FREQ-строку:
		    в SHpass2.C:HabFreqPart() вместо OutLinesBegin( " &FREQ" );
		    доделан еще параметр к функция OutLinesBegin():
			OutLinesBegin( " &FREQ", OUT_LAST );
		2)Директива ".HB_OPTIONS" (см. п.5) , содержит разные параметры.
		  Разрешить несколько директив на один файл. Параметры могут
		  появляться в директиве сразу по несколько или по одному.
		  Если параметр ранее не встречался - он просто определяется.
		  Если уже встречался - то переопределяется, ему присваивается
		  новое значение
		  - все именно так и работает
		*.Y: добавлена диагностика в обработке .ENDS:
		- сбой при занесении информации о конце схемы
		- если .SUBCKT и .ENDS находятся не в одном файле - ошибка
		*.Y, первый проход:
		- подправлена диагностика сообщения о наличии подсхемы с
		  одинаковым именем
	?	- после этого необходимо прекращать разбор, иначе появляются
		  сообщения о дублированных именах элементов для данной схемы:
		    MsgErrorFatal( exitPARSEREXIT, msgPARSEREXIT );
		  а это угрожающее сообщение с обрывом трансляции:
		    "*FATAL* Parsing exit on unrecovering error"
		  - пока закомментарено
		диагностика "Element with name 'XXX' already exist" должна
		  содержать и информацию о схеме - пока лишь добавлен хвост
		  сообщения "...in this circuit"

21.03	0.77	продолжение отладки вызовов подсхем:
#61		- при попытке вызова не втором проходе несуществующей схемы
		  надо не проводить генерацию кода (msgSUBCKTNOTEXIST)
		  добавлено 'else' 
		- обработка подсхем правильно работает на первом проходе,
		  а на втором - не восстанавливается правильно circCall после
		  вызова, причем может происходить зацикливание с диагностикой
		  "(lex) Maximum include files nesting (32) exceed"
		  - не восстанавливается указатель подсхемы после пропуска
		    определения подсхемы внутри вызова

22.03	0.78	отладка :(
#62		так как работа не клеится, будем писать:
		алгоритм обработки подцепей сегодня такой, но что-то не так:
	Xxxx ... SubXX
		{Pass1: никаких действий
		 Pass2:
			circThis = FindSubCirc(SubXX)
			if circThis==NULL ошибка: вызов несуществующей схемы
			else if(
			  !isSubDefBody
				/* вызов из главной схемы */
                        || isSubDefBody && isSubCall && (circCall == circDefCurrent)
				/* вызов из уже разворачивающейся схемы */
			)
			{/* генерация вызова: */
				PushCircStack();
				isSubCall = TRUE;
				levelSubCall++;
				circCall = circThis;
				/* rename local nodes... */
				/* rename local elements... */
				IncludeFile( circThis->begfname, circThis->begline );
			}
		}
	.SUBCKT ...
		{	isSubDefBody = TRUE;
			levelSubDef++;
			PushCircStack();
		 Pass1:	if	такая схема на этом уровне уже есть - ошибка
			else	circDefCurrent = свежедобавленная схема
		 Pass2:	circDefCurrent = эта схема
		}
	.ENDS
		{ if( PassNo == 1 ){
			PopCircStack();
			AddSubCircEnd(...) - добавить информацию о месте .ends
			проверить, в одном ли файле лежат начало и конец цепи
                  }/*pass1*/
		  if( PassNo == 2 ){
			if( isSubDefBody && isSubCall && (circCall == circDefCurrent)
				/* конец вызова подсхемы */
			){
				ReturnPrevFile();
				PopCircStack();
				if( isSubCall ) levelSubCall--;
				if( levelSubCall == 0 ) isSubCall = FALSE;
			}
			PopCircStack();
                  }/*pass2*/
                  levelSubDef--;
                  if( levelSubDef == 0 ) isSubDefBody = FALSE;
		}
		вроде одну багу вымучил..., зато теперь Вижуал падает где-то
		  и на первом проходе, и на втором (на разных тестах)

	0.79	попытка перейти на GCC-2.95.2:
		- LEXLIB.A - сделано (MAKELIB.GNU)
	!	NB: в GNUшном MAKE-правиле команды должны начинаться только
		  табуляцией, а не пробелами
		- S2H-компилятор - (MAKEFILE.GNU) - не доделано, надо читать
		  документацию по GNU-MAKE

23-25	0.80	продолжение перехода на GNU_C:
#63		- у MAKE, как и предполагалось, свои фокусы - выделить чисто
		  имя без расширения не удалось: $(*F) = \name
		- у гну-Са *.H-файлы лежат не в .\include\, а в include\g++-3\
		  (и как winDOSя это переварит?), а точнее в
		  HD  = T:\i386-mingw32\include # GNU C headers directory
		  LIB = T:\i386-mingw32\lib     # GNU C libraries directory
			но это не понадобилось
		- гну-Сный MAKE интерпретирует V:\SHmain.o как V:SHmain.o,
		  поэтому в путях правил и вызовах гну-Сных утилит пришлось
		  заменять "\" на "\\", но в DOS-командах надо все оставлять
		  по-старому
		- регистр в написании _расширений_ файлов играет роль и в
		  правилах, и в гну-С-командах, и в #include'ах в исходниках
		- в SRC-каталоге иногда появляется мусор в виде *.cc.regmove и
		  *.cc.gcse файлов
		- иногда сама добавляется директива трансляции (?)
		- непонятная ошибка в MAKEFILE:
		    *Initialization*:1: warning: this is the location
						 of the previous definition
		  причина: макрос WIN32 был уже определен где-то внутри гнуса
		- Lex генерирует конструкцию, не съедобную для гну-Са:
		    FILE *yyin ={stdin}, *yyout ={stdout};
		  надо браться за Lex-исходники, разрывая эту конструкцию на две:
		    FILE *yyin, *yyout; - в области определений
		  и в начале yylex():
		    yyin = stdin; yyout = stdout;
		  ? а может в гну-Се есть ключик, делающий его совместимым с
		    другими компиляторами (Options Controlling C Dialect):
		    -ansi		- не помог, добавил ошибки к функциям с
					  переменным числом параметров
		    -flang-isoc9x	- ???
		    -traditional	- лавина ошибок типа
						parse error before `char'
		  ! ключ совместимости за разумное время найден не был, поэтому
		    был переделан Lex как описано выше
		- все оттранслировалось (скорость трансляции у гну-С еще ниже,
		  чем у вижуал-с)
		- еще одна странность - в конструкции типа
		    LEXLIB  = T:\lib   # Directory with LEX-library
		  переменной присваивается значение "T:\lib   " с хвостовыми
		  пробелами перед # (но похоже не всегда !?)
		- похоже, что библиотеку мало собрать с помощью AR, ее надо еще
		  и RANLIB, то же надо сделать и с LEXLIB.A
		- еще одна гну-Сная особенность ld-сборщика:
		  - ключ -lбиблиотека обозначает включение в процесс сборки
		    библиотеки LIBбиблиотека.A, находящейся либо в стандартном
		    месте, либо в каталоге, указанном ключом -Lкаталог
		  - пришлось переименовать LEXLIB.A в LIBLEX.A
		- теперь компиляция происходит, а сборка - нет, так как не
		  находятся стандартные функции библиотеки C:
		  - попытка добавить все найденные библиотеки ничего не дала:
			ld ... -lg2c -lgcc -lobjc -lstdc++ -liberty
		  - зато gcc сам находит нужные библиотеки, поэтому
		    окончательную сборку удалось сделать с помощью gcc:
		      $(CC) -o $@ $(WRKDIR)\\SHmain.o $(OBJ) -L$(LEXLIB) -llex
		    теперь стандартные библиотеки нашлись, но не находятся
		    при сборке функции, определенные в $(OBJ), и вызываемые из
		    SHmain - множество сообщений типа:
			SHmain.o(.text+0xcc5):SHmain.C:
			 undefined reference to `MsgDebug(char *,...)'
		- при попытке перенаправить лавину диагностики
		  в файл с помощью "gcc ... >файл" получаем сообщение
			GCC.EXE: V:\\SHmain.o: Permission denied
		  причем на все входные файлы
		- функции searchpath() в гну-С тоже нет
	?	? вместо
		    YACC  -d SHpars.y
		    copy  /b ytab.c $(WRKDIR)\SHpars.c
		  оно само пыталось делать:
		    yacc  SHpars.y
		    mv -f y.tab.c SHpars.c  - это нельзя под DOSей
		- попытка отказаться от libSHpr.a, а собирать объектные файлы
		  тоже ничего не дала - теперь, похоже, слишком длинная командная
		  строка для gcc
	?!	? еще одна странность гну-Сного MAKE - при любом запуске он
		  абсолютно все перекомпилирует сначала - спрашивается, зачем
		  надо было огород городить, когда можно написать обычный
		  командный файл ?!
		- итог: собрать проект с помощью GNU C пока не удалось

26.03	0.81	борьба с гну-Сом продолжается:
#64		- после переделки Lex'а описанным в v.0.80 способом хабалятор
		  начал виснуть как под Борландом, так и под Вижуалом, поэтому
		  - возвращаемся к старому Lex'у
		  - после генерации lexyy.c в makefile.gnu вставляется
		    специально написанная программа
		      ANTIGNUC.exe <lexyy.c >$(WRKDIR)\\SHlpars.c
		    заменяющая строку
		      FILE *yyin ={stdin}, *yyout ={stdout};
		    на
		      FILE *yyin, *yyout; - в области определений
		  - специально для гну-С у хабалятора в main() вставляется
		      yyin = stdin; yyout = stdout;
		  - кстати, из-за гну-Сных особенностей make нельзя писать
			@$(LEXCNV) <lexyy.c >$@
		    а приходится писать явно
			@$(LEXCNV) <lexyy.c >$(WRKDIR)\SHlpars.c
		    так как DOSя "\\" в имени файла не переваривает
		- сделан ANTIGNUC.exe в 4-х вариантах: для 2-х Борландов,
		  Вижуала и Гну-Са
		? или мне показалось, или у гну-Сного make еще одна особенность:
		  команды, закоментаренные в начале строки "#\t" могут быть
		  отправлены на выполнение - вот фрагмент диагностики, взятый
		  прямо с экрана:
		    #       GCC -o V:\\S2H.EXE SHmain.c V:\\SHpars.o
			 V:\\SHlpars.o V:\\SHiofun.o V:\\SHpass1.o
			 V:\\SHpass2.o V:\\SHconfig.o -llex	(команда с #)
		    Слишком много параметров - GCC		(диагностика)
		  если после комментария нет табуляции, а пробел ("# ") - все OK
		- в последнем неработающем правиле
		  $(WRKDIR)\\$(sPROGNAME).EXE:  SHmain.c $(OBJ)
			# ...
			$(CC) $(OPT) -o $@ $< $(OBJ) -llex
		  заменяю последнюю команду на ее расшифровку
			GCC $(OPT) -o V:\\S2H.EXE SHmain.c V:\\SHpars.o
				 V:\\SHlpars.o V:\\SHiofun.o V:\\SHpass1.o
				 V:\\SHpass2.o V:\\SHconfig.o -llex
		  и все начинает компилироваться !
		  - причиной глюков были закомментаренные строки перед вызовом
			$(CC) $(OPT) -o $@ $< $(OBJ) -llex
		    после их удаления и это правило работает нормально
		- последнее замечание гну-Са заключалось в том, что main()
		  должна возвращать int, а не void, поэтому сделано
			#ifdef GNU_C
			    int
			#else
			    void
			#endif
			main( ...
		? интересная особенность компиляторов: перекомпилируя проект
		  любым борландовским компилятором (DOS-приложение), получаем
		  идентичные *.exe, при перекомпиляции Вижуалом или гну-Сом
		  (Win32 консольные приложения) полученные *.exe отличаются
		  по крайней мере двумя байтами
		- несмотря на потраченные усилия, makefile.gnu работает как
		  командный файл, производя полную перекомпиляцию проекта
		  при каждом запуске:
		  - удаление всех комментариев не помогло
		  - вероятно, причина в том, что исходники и объектные файлы
		    разнесены по разным каталогам, а make плохо понимает
		    имена файлов с "\", даже удвоенными - подтверждение этому -
		    то, что make для LEXLIB и ANTIGNUC работает правильно
		  ! лучше позже, чем никогда - замена в именах файлов "\\"
		    на "/" помогла - теперь все OK
		- отлажен и вариант makefile, когда все объектные модули
		  (кроме SHmain) собираются в библиотеку
		- не работает попытка откомпилировать предварительно и SHmain.c,
		  а затем все собрать, то есть при
			$(CC) $(OPT) -o $@ SHmain.o $(OBJ) -llex
		    происходит лавинообразная диагностика о неразрешенных ссылках
			V:/SHmain.o(.text+0xdba):SHmain.C:
				 undefined reference to `Pass1(void)'
		  а работает только когда SHmain.c компилируется перед сборкой:
			$(CC) $(OPT) -o $@ SHmain.c $(OBJ) -llex
		- кстати, RANLIB - это что-то вроде построителя индексов в
		  (больших) архивах, - все работает и с ним, и без него
		итак, переход к гну-Су будем считать завершенным, так как силы
		  для борьбы после 3-х дней на исходе и кончились слова...

	0.82	продолжение работ:
		- если происходит зависание S2H.exe, сделанного гну-Сом,
		  то "высоконадежная" Вынь98вСЕ (4.10.2222) падает так,
		  что помогает только press any key RESET,
		- в этой же ситуации S2H.exe, сделанный Вижуалом, говорит
		  "Программа выполнила недопустимую операцию и будет закрыта",
		  на жизнеспособность винды это не влияет,
		- если виснет Борландовский S2H.exe, то снять его с помощью
		  Ctrl+Break, Ctrl+C удается не всегда, поэтому лучше запускать
		  его в отдельном окне (впрочем, как и все варианты) - в этом
		  случае окно можно закрыть кнопкой закрытия [X], сняв таким
		  образом зависшую задачу
		- Борланд компилирует быстрее всех, гну-С - медленнее всех
		- существенный недостаток борланд-С-3.1 - глюки под WinNT4
		- для Винды9х фатально зависание только гну-Совых программ
		продолжение отладки подсхем:
		- проблемы есть только в сильнонавороченных схемах с includ'ами
		- если все находится в одном файле, то вроде работает -
		  вероятно дешевле написать препроцессор, чем отлаживать навороты
	!	  но тогда необходимо, чтобы данный компилятор обрабатывал
		  директиву вроде #line, чтобы MsgCompile() и консольная
		  диагностика правильно показывала, что обрабатывается
		  или это должна делать оболочка, восстанавливая по ошибке
		  в собранном файле ссылку на исходник
		*.Y: если при описании подсхемы в параметрах-узлах встретился
		  '0' - это ошибка первого прохода

27.03	0.83	при генерации кода для каждого элемента прописывается строка
#65		  в файл трансляции имен элементов S2Helems.tmp - функция
		  SHpass1.C:PrintElemsTransl()
		печать в S2Hnodes.tmp трансляций имен узлов:
		- в конце Pass1() для главной цепи:
		    PrintNodesTransl( NULL/*MainCircuit*/, listNodesMain );
		+ для каждой вызаваемой в Xxxx цепи:
		    PrintNodesTransl( circCall, circCall->nodeparmlist );
		при вызове (на втором! проходе) собрать узлы-фактические
		  параметры вызова подсхемы во временный список:
		- тип SubParm - список фактических параметров-узлов
		- SubParm *parmSubCall; - в *.Y
		- SHpass2.C:PrintSubParm( parmSubCall ); - для отладки
		- SHpass2.C:AddSubParm( parmSubCall, имя );
		- при несовпадении количества формальных и фактических
		  параметров при вызове выдается сообщение
		- DelParmSubCall( parmSubCall );

28.03	0.84	скомпилированный под NT4 хабалятор падает на одном из примеров
#66		  в конце первого прохода (и под гну, и под вижуал):
	???	? зависает SHconfig.C:OutHabSERVIS() на операторе
		    Out( SERVHD );
		  где SERVHD - это строка " &SERV ",
		  а SHiofun.C:Out() - процедура с переменным числом параметров
		    для вывода в fileOut, это ее первый вызов
		  ! глюк происходит в Out() при вызове
		    vfprintf( fileOut, msgfmt, arguments );
		    причем данный эффект наблюдается только для одного примера
		    с большим количеством подсхем и их вызовов
		! причина не в этом месте программы, а похоже, что в NT4:
	???	  ? неужели в NT как-то ограничено количество открываемых файлов
		    и надо трогать какие-то настройки NT4:
		  - добавление в SHmain.C контрольных выводов "\n" в каждый
		    из открываемых файлов привело к тому, что программа падает
		    уже на выводе в третий по порядку файл:
			fileOut = fopen( nameFileOut, "w" );		...
			Out( "\n" ); /* test out */
			fileNodes = fopen( nameFileNodes, "w" );	...
			OutNodeTr( "\n" ); /* test out */
			fileElems = fopen( nameFileElems, "w" );	...
				- открывается ОК
			OutElems( "\n" ); /* test out */
				- ПАДАЕТ
			/* open error messages file: */			...
			MsgError( "\n" ); /* test out */
			fileDebug = fopen( nameFileDebug, "w" );	...
			MsgDebug( "\n" ); /* test out */
			fileTmp = fopen( linebuffer/*nameFileTmp*/, "w" );	...
			OutTmp( "\n" ); /* test out */
		  - раз такое дело, ставлю открытие fileError первым, а
		    fileDebug - вторым (на всякий случай), теперь:
			MsgError( "\n" ); /* test out */
			MsgDebug( "\n" ); /* test out */
			Out( "\n" ); /* test out */
			OutNodeTr( "\n" ); /* test out */
				- OK
			OutElems( "\n" ); /* test out */
				- ПАДАЕТ
			OutTmp( "\n" ); /* test out */
		    последнее проверено на нескольких входных примерах
		  - S2H.exe скомпилированный под NT+GNU и перенесенный в Win95
		    упал в том же месте с диагностикой
		    "Сбой при обращении к странице памяти в модуле CRTDLL.DLL
		     по адресу 0157:7fd0b2fc" - одинаково для всех входных файлов
		  - пробую NT4+BorlandC++3.1: этот честно сказал
		      *FATAL* Error on output stream 'S2HNODES.TMP'
		    правда "\n" в 'S2HNODES.TMP' вывести успел
		  ! кстати, если сборку Борландом проводить с помощью MK.BAT,
		    а не запуская борландовский MAKE руками, то все в порядке

	0.85	кое-что вылечилось - была ошибка в OutNodeTr():
		    CHECKSTREAM( fileTmp, nameFileNodes );
		  вместо
		    CHECKSTREAM( fileNodes, nameFileNodes );
		  где	# define    CHECKSTREAM( file, name ) \
			    if( ferror( file ) ) \
			        MsgErrorFatal( exitOUTFAIL, msgOUTFAIL, name )
		  и вызывалось оно до того, как fileTmp был открыт - поэтому
		    такая непредсказуемость - ошибка пропала после того, как
		    открытие fileTmp было поставлено раньше открытия fileNodes
		но под NT4 только что работавшая под Win9x программа снова
		  сбоит, причем под GNU C сбой на втором проходе происходит
		  раньше всего, под Visual C тоже до конца не доходит, а
		  под Borland C все проходит до конца (пример Sub2.spi)
		новая информация к размышлениям:
		- скомпилированный под NT+GNU (с ключом -g для отладки) S2H.exe
		  обламывается на Sub2.spi на 3-й строке во втором проходе c
		  "Dr.Watson: Exception: access violation 0xc0000005, address:
		   0x77f7d465"
		- _этот_ же S2H.exe запущенный через отладчик доходит до конца:
		  > gdb S2H.exe
		  > (gdb) set args Sub2.SPI SP3out.obj -eSP3error.tmp
				 -dSP3debug.tmp -t. -g -1 -2 -k
		  > (gdb) run
		  но с предупреждением:
		    warning: HEAP[S2H.EXE]:
		    warning: Heap block at 24452e0 modified at 24452f1
					 past requested size of 6
		    Program received signal SIGTRAP, Trace/breakpoint trap.
		    0x77f7629d in ?? ()

29.03	0.86	продолжение обработки схем:
#67		- circPrepCall в .SUBCALL
		- на первом проходе создавать listX
		- создание listR/L/C - тоже на первом проходе (исправлено)
		- Pass1: в список узлов схемы на первом приходе добавлять и
		  узлы от элементов Xxxx - в правиле SubCallNode
		- теперь в списках узлов схем выдаются и узлы, встречающиеся в
		  элементах Xxxx
		в конце первого прохода элементы из подсхемы переименовываться
		  не должны (точнее, им не надо присваивать новое имя сразу):
		- SHpass1.C:AddElem(): if( parent == NULL ) переименовывать...
		- SHpass1.C:RenameElems(): добавлен параметр circuit - к какой
		  схеме принадлежит элемент - переименовываться будут только
		  элементы нужной подсхемы
		- SHpass1.C:FindHabElem(): тоже добавлен параметр circuit
		- SHpass1.C: добавлена процедура RenameAllElems(схема)
		- SHpass1.C:DebugPrintElemLists(): добавлен параметр circuit,
		  и в PrintElemList() тоже
		*.Y: перед вызовом подсхемы:
		- RenameAllElems(схема)
		- DebugPrintElemLists(схема)

30.03	0.87	пока отладка - на Borland, так как GNU C - крахует, а под
#68		  отладчиком говорит:
		    warning: HEAP[S2H.EXE]:
		    warning: Heap block at 2453da8 modified at 2453db6
					 past requested size of 6
		    Program received signal SIGTRAP, Trace/breakpoint trap.
		    0x77f76149 in ?? ()
		печать (переименованных) узлов подсхемы перед вызовом (если
		  задан флаг '-2'): PrintNodesList( circCall->circnodlist );
		печать узлов-формальных параметров схемы
		введены константы lenHABNAME = 4, lenHABNAME0 = 5,
		! надо помнить, что число 4 используется в спецификации форматов
		  вывода: "%4s"
		в RenameLocalNodes() для списка узлов-формальных параметров
		  схемы в качестве новых имен подставлять фактические параметры:
		! подставлять надо не фактические параметры-спайс_узлы,
		  а их 4-символьную хабала-трансляцию для родительской подсхемы
		печать хабала-опций в отладочном файле только при отладке
		  первого и второго проходов

31.03	0.88	переименование локальных узлов при вызове подсхемы в
#69		  RenameLocalNodes() с учетом того, что
		- узел '0' не переименовывается
		- остальные узлы переименовываются с учетом счетчика
		  переименований для узлов
		  - для этого SHpass1.C:RenameNodes(список_узлов):
		    - сделана общей
		    - введен глобальный счетчик переименований узлов renNodes,
		      константы startRENNODES, stopRENNODES
		    - узел с именем "0" переименовывать не надо
		    - упрощена логика работы функции - так как она писалась
		      вначале только для переименования узлов главной схемы,
		      она сначала искала узел '0', теперь этого нет, так как
		      в подсхеме узла '0' может и не быть
		- вместо формальных узлов-параметров подставляются фактические
		  (в том числе может быть подставлен и '0')
		+ после этого проверить, правильно ли подставляются в
		  RenameLocalNodes() фактические параметры для списка
		  узлов-формальных параметров схемы
	?	- система переименования работает, но имеет недостаток -
		  нерациональное использование номеров хабала-узлов, так как
		  вначале функция RenameNodes() переименовывает все узлы,
		  кроме '0', после чего подставляются узлы-фактические параметры,
		  затирая таким образом уникальные драгоценные номера из
		  диапазона 1..9999, но если номера узлов в хабале не ограничены
		  числом 9999, тогда можно расширить поле newname[5] для узлов
		в *.OBJ-файл номера узлов выводятся неправильно:
		  GetHabNodeName() в *.Y вызывалась параметром-списком_узлов
		  главной схемы, а надо - со списком узлов текущей - исправлено

01.04	0.89	тестирование на примерах примеры, взятые с
#70		  http://www.ee.ualberta.ca/~charro/cookbook/spice/analog/
		  почти все не работают, так как в них встречается конструкция
			EXXXXXXX N+ N- POLY(1) NC+ NC- VALUE
		  вместо описанной в документации
			EXXXXXXX N+ N- NC+ NC- VALUE
	?	? на группе примеров T1, T2, T3 обнаружено зацикливание на
		  T2.spi:10: .include T3.spi - после обработки подсхемы Sub2
		  из T3.spi происходит возврат (по .ends, а не концу файла)
		  на тот же T2.spi:10: .include T3.spi (на первом проходе это
		  не происходит, только на втором)
		  причина: в *.Y при вызове ReturnPrevFile() производится
		    уменьшение номера строки в восстанавливаемом файле после
		    обработки вызова Xxxx:
		      /* for subcall: */
		      if( isSubCall && levelSubCall > 0 ) lno--; /*ASB000221*/
		  - это было сделано для того, чтобы при возврате из вызова
		    подсхемы не пропадала следующая за обработанным оператором
		    Xxxx сторока
		  - перед зависанием выполняется ReturnPrevFile() для .include
		    с состояниями level SubDef = +1, level SubCall = +1,
		    поэтому и происходит lno--, то есть из стека возвращается
		    тот же номер строки, на котором был .include
		  - заменено на
		    if( isSubCall && (levelSubCall > 0) && (circCall == circDefCurrent) )
		 	lno--; /*ASB000401*/
		  - не помогло, поэтому в ReturnPrevFile() добавлен параметр
		    isFromInclude, показывающий, откуда производится вызов,
		    теперь
		    if( !isFromInclude && isSubCall && (levelSubCall > 0)
		        && (circCall == circDefCurrent) )
		 	    lno--; /*ASB000401*/
		  - задышало !
		в S2Helems.tmp - выравнивание хабала-имен по левому краю (%-s)
		  в msgELEMTRANSLINE (даже не %-4s, чтобы в хабала-имени <4
		  знаков не появлялись пробелы, так как в данном файле
		  разделителем может быть только \t)
		в S2Hnodes.tmp - то же сделать не удалось так как в newname
		  узлов содержатся хвостовые пробелы, возникшие в результате
		  переименования в SHpass1.C:RenameNodes():
		    sprintf( pn->newname, "%-4ld", renNodes );
		  поэтому сделано:
		    for( i=0; i<lenHABNAME; i++ ) pn->newname[i] = '\0';
		    sprintf( linebuffer, "%-4ld", renNodes );
		    /* удалить хвостовые пробелы: */
		    lb = linebuffer;
		    while( isdigit(*lb) ) lb++;
		    *lb = '\0';
		    strncpy( pn->newname, linebuffer, lenHABNAME );

03.04	0.90	сделан документ S2H_CALL.TXT, описывающий запуск и работу
#71		  программы для разработчика интерфейса "Программа S2H
		  как текстовый конвертор из Spice в Хабала"
		переименование S2HABALA.CNF в S2H.CFG
		внесение генерации Lex-библиотеки в сам проект
		- причина: слишком много целевых компиляторов и для каждого
		  в его LIB-каталог нужно положить сгенерированную заранее
		  библиотеку Lex'а
		- предусмотреть и возможность стандартного присоединения
		- сделано для:
		  - Borland C++ 3.1
		  - Visual C++ 4.0
		  - GNU C++ 2.95.2
		пробная компиляция на MS C v.6.00 - не получилось - слишком
		  большой YACC-исходник:
			SHpars.y(3271) : fatal error C1002:
				 compiler is out of heap space in Pass 2

04.04	0.91	вторая редакция S2H_CALL.TXT
#72		флаг '-s' запрещен по умолчанию
		начало сбора в список моделей на первом проходе в listModels:
		- имя
		- тип
		- указатель на подсхему, в которой встретился
		- указатель на список пар-параметров
		SHpass1.C:
		- DebugPrintAllModels()
		- PrintModelParmList(список)

05.04	0.92	SHpass1.C:
#73		- FindModel(имя,схема)
		доделки после тестирования заказчиком:
		- *.L: '_' может быть в начале имени:
		  заменено <CODE>{LETTER}({IDLETTER}|{DECDIGIT})*
		  на	   <CODE>{IDLETTER}({IDLETTER}|{DECDIGIT})*
				/* only identifier inside line */
	?!	- *.Y: программы без .end зависают, а должны просто заканчиваться
		  c сообщением "неожиданный конец файла" - изменение грамматики:
		  обработка .END перенесена в список операторов, вызывая
		   _END         ={ cnt_END++; /* .END indicator */
		                   return cntErrors;
		                 }
		  - не помогло !!?
		  - а "помогло" удаление из списка операторов StatementList
		    пустого оператора "/*free line*/ _ENDOFSTMT_"
		    но при этом	"conflicts: 196 shift/reduce, 2 reduce/reduce" !!
		  - а введу-ка я лексему _EOF_, которую возвратит Lex
		    при достижении конца файла - тоже не получилось -
		    возврат TRUE происходит из yywrap()[а не из yylex()],
		    yylex при этом возвратит 0 и этот 0 (признак конца файла)
		    должен быть обработан Yaccом, вместо чего тот ожидает все
		    что угодно, только не EOF
		? может в YACC есть предопределенная лексема, обозначающая конец
		  файла
		- убрана часть правила
		   ProgramBody :
			...
		 | error        ={ MsgError( msgERRINPROG ); ++cntErrors;
		                   CheckCircBrackets();
		                   return cntErrors; 
		                 }
		   _END         ={ cnt_END++; /* .END indicator */ }
		 | StatementList error
		                ={ MsgCompile( msgNEED_END );
		                   /* CheckCircBrackets(); */
		                   return cntErrors; 
		                 }
		   /*_ENDOFSTMT_*/
		- убрана лексема _EOF_, вместо этого устанавливается глобально
		  isEOF = TRUE и анализируется в *.Y при распознавании элемента
		  StatementList при диагностике пользоваться MsgCompile()
		  нельзя, так как указатель текущей строки указывает за пределы
	!?	  файла - так проблема отсутствия .END частично решилась -
		  если в конце входного файла есть либо 2 пустые строки, либо
		  комментарий+пустая строка, то все ОК
		- до изменений:
			118/127 terminals, 238/250 nonterminals
			446/500 grammar rules, 798/1000 states
			238/250 working sets used
			memory: states,etc. 3828/5200, parser 858/4000
		  после:
			118/127 terminals, 237/250 nonterminals
			444/500 grammar rules, 794/1000 states
			237/250 working sets used
			memory: states,etc. 3805/5200, parser 860/4000

07.04	0.93	попытка вставить в *.Y в StatementList пустое правило с проверкой
#74		  на EOF тоже ничего не дало, кроме 200 shift/reduce
		SHpass1.C:
		- AddToModelList(имя,тип,схема)
		- AddModelParm(имя,схема, имяпарам,естьзнач,значение)
		почти работает, но если значение параметра отрицательно - глюк
		  в *.Y - исправлен - была ошибка в правиле для Value со знаком
		отладочная печать моделей работает

	0.94	если параметер с таким же именем уже существует - ошибка:
		- FindModelParm(схема, параметер)
		- FindModelParm() вставлен в *.Y для Pass 1
		? а может ли в модели быть несколько параметров-чисел ?
		тестирование и доделки на примерах заказчика от 06.04.2000:
		TEST1:
		- buf600x1.mod: схема без .end висла под v.0.89, сейчас не
		  виснет (хотя должна;) - выдает сообщение
		TEST2:
		- buf600x1.cir: в файл трансляции узлов недовыводятся внутренние
		  узлы подсхемы после перенумерации, а только узлы-параметры:
		  в *.Y добавлен вывод всех узлов:
			PrintNodesTransl( circCall, circCall->circnodlist );
			    /* - all nodes */
		  вместо одних только узлов-параметров:
			PrintNodesTransl( circCall, circCall->nodeparmlist );
			    /* - nodes-parameters only */
		TEST3:
		- buf600x2.mod: отсутствует закрывающая скобка в описании модели:
			.MODEL PIJ PNP
			+(BF  = 110 IS  = 0.1567E-16
			+	.	.	.
			+VAF = 39.00     NC  = 1.634    VTF = 2.680 
		  на что сказано:
		  File BUF600X2.MOD: line 77.end:  Error in .MODEL statement:
			+VAF = 39.00     NC  = 1.634    VTF = 2.680 
			                                            ^
		  претензии не принимаются, но для более точной диагностики
		    сделано в *.Y:
			maybeModelParameters : ...
			 | '(' ModelParameters BRKEND/*')'*/ ;
		TEST4:
	?	- buf601x1.cir: а этот пример упрямо виснет без .END - пока
		  ничего сделать не могу
		TEST5:
		- buf601x2.mod: OK
		TEST6:
		- ina103.mod, ina103-2.cir:
		  - об отсутствии .END сообщается (в этой версии хабалятора)
	???	  - взятие в скобки и разделение запятыми узлов - у меня нет слов:
		    File INA103.MOD: line 102.12:
		      Error in Linear Voltage-Controlled Voltage Source 'EGND':
			EGND 99  0 (3,0) .5
			           ^
		  - так тоже нельзя - 4-й параметр в Fxxx должен быть значением
		    (в спецификациях: FXXXXXXX N+ N- VNAM VALUE):
		    File INA103.MOD: line 103.16:
		      Error in Linear Current-Controlled Current Source 'FB':
	?		FB    7 99 VB VC 2.653E6 
			               ^
		- ina103.cir, ina103-1.cir:
		  вызов неописанной подсхемы INA103 - так нельзя
		- ina103-3.mod: об отсутствии .END теперь сообщает
		- ina103-3.cir, в которой делается include ina103-3.mod:
	!	  вызов из схемы INA103 подсхем A1_103, A2_103, A3_103, описанных
		  _вне_ ее - надо преределывать поиск подсхемы перед диагностикой

08.04	0.95	поиск описания тела подсхемы перед вызовам производится не только
#75		  в текущей схеме, но и во всех ее предках вплоть до главной
		! а в схемах-братьях не ищется:
		- сделана FindSubCircHigh() кроме FindSubCirc()
		- FindSubCirc() - ищет только в текущей (а искала еще и в главной)
		- FindSubCircHigh() - ищет, начиная с токущей, у всех родителей,
		  заканчивая главной
		- начались глюки:
		  - теперь неправильно переименовываются параметры, которые
		    раньше брались из родительской, а не вызывающей, схемы:
		    в RenameLocalNodes() добавлен параметр - вызывающая схема
		  - не формируются хабала-элементы при вызове подцепи, а только
		    для главной:
	?	    - теперь не выполняется условие для генерации кода для
		      элемента
			isSubDefBody && isSubCall && (circCall == circDefCurrent)
	?	    - при обработке Xxxx после того как вызываемая подсхема
		      найдена и производится прыжок не нее, не выполняется
		      условие isSubCall && (circCall == circThis ) для
			"process call subcircuit ..."
		      а вместо этого isSubCall && ( circCall != circThis ):
			"begin of skipping subcirc def body in subcall ..."
	!!	      так как после "Pass1,2: after process '.subckt'"
			неправильно устанавливается circDefCurr
		      - причина: FindSubCirc() не была заменена и здесь на
			FindSubCircHigh()
		  - заработало, но необходимо тестирование

09.04	0.96	ключи -n, -m, -t перенесены из дополнительных в основные
#76		ключ командной строки '-u' преобразования всех латинских букв
		  входного потока в верхний регистр:
		- переопределением yyinput(){ return(input()); } не получилось,
		  так как его определение генерирует Lex (можно конечно выкусить
		  это определение из NCFORM.C, но лучше так не делать)
		- в правила Lex'а дописывается, где надо
		  if( Flags[flagU].value ) strupr( yytext );
		- но ошибочная диагностика MsgCompile() дается в том виде, что
		  и во входном потоке - тоже переделано - в PrintLine()
		- а из-за этого, в свою очередь, пришлось _во_всех_ правилах
		  Lex'а поднимать регистр, даже в строковых константах и
		  комментариях
		- в отладочные bat-файлы вставлен ключ '-u'
		продолжене тестирования и доделок на примерах заказчика от 06.04.2000:
		TEST8:
		- mpc100x1.cir: раньше не находились определения подсхем -
		  теперь ОК
		TEST7:
		- всплыла ошибка (iso120x.cir): если элементы имеют одинаковые
		  имена в разных регистрах (например, 'R1' и 'r1'), то они
		  транслируются в одно хабала-имя R1
		- то же происходит для элементов с одинаковыми именами,
		  находящимся в разных подсхемах
		- причина в SHpass1.C:RenameAllElems(), точнее в RenameElems(),
		  добивающейся уникальности хабала-имен в пределах схемы,
		  а по-другому нельзя, так как история переименований для всех
		  схем не хранится, ее можно восстановить только по файлу
		  S2Helems.tmp, который надо просматривать в RenameElems()
		! поэтому элементы из подсхемы переименовывать _всегда_
		  в RenameElems()
		? или переименовывать элементы всегда, не пытаясь сохранить
		  оригинальные spice-имена, усекая их до 4-х символов ?
		  (правда для главной цепи только)

10.04	0.97	продолжене тестирования и доделок на примерах заказчика от 06.04.2000:
#77		TEST4: buf601x1.cir:
		- найти, где в программах без .END происходит зацикливание
		- под отладчиком (Borland) выяснилось, что зависание происходит
		  в SkipRestLine(), определенной в *.Y и вызываемой в случае
		  ошибки в *.Y для пропуска остатка ошибочной строки,
		  вставка в SkipRestLine()
			if( ch == 0 ) break; /*EOF*/
		  пока не помогла, теперь зависает в другом месте - в *.Y -
		  отладчик не может правильно позиционироваться в тексте с
		  #line
		- *.Y: замена везде SkipRestLine() на макрос SKIPTOEOLN,
		  проверяющий заодно и окончание входного потока - не помогло
	?	- теперь зависание обнаружено при многократном вызове
		  MsgCompile(), когда fileInp уже закрыт - добавлено
		    if( isEOF ){
		      MsgErrorFatal( exitERR_ENDNOTFND, msgERR_ENDNOTFND );
		      return;
		    }
		  вызывающее аварийное завершение программы, но осталось
		  неясным, кто же вызывал MsgCompile() - отладчик Borland
		  стек вызовов не показал
		- *.Y: восстановлено правило (удаленное 05.04.00) в недежде,
		  что оно перехватит отсутсятвие .end до возникновения
		  фатальной ошибки:
		   ProgramBody : ...
		    | StatementList error
			={ cntErrors++; MsgError( msgNEED_END );
                        	      /*MsgCompile( msgNEED_END );*/
				      /* CheckCircBrackets(); */
			   return cntErrors; 
			 }
		  - не помогло

11.04	0.98	Попробовал: Node : ['('] NodeName [','|')']
#78		  изменение коснулось:
		- _SUBCKT NodeName/*Identifier*/
		- _ENDS   NodeName/*Identifier*/
		- SUBCALL SubCallNodeList NodeName/*Identifier*/
		- ArExpr : Identifier '(' NodeName ',' NodeName ')' /*OutVar*/
		- Node	: NodeName
			| '(' NodeName ')'
			| '(' NodeName ','
			| ',' NodeName
			| NodeName ')'
			;
		  дает 1 shift/reduce, на пределе состояния (>800 м.б. фатально):
			118/127 terminals, 239/250 nonterminals
			451/500 grammar rules, 804/1000 states
			1 shift/reduce, 0 reduce/reduce conflicts reported
			239/250 working sets used
			memory: states,etc. 3865/5200, parser 935/4000
		- введение NodeName добавило:
			118/127 terminals, 239/250 nonterminals
			447/500 grammar rules, 797/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			239/250 working sets used
			memory: states,etc. 3825/5200, parser 952/4000
		В модели:
		- не может быть параметров-чисел без идентификатора
		- кроме записи параметра модели "ПАРАМ '=' ЧИСЛО"
		  может быть "ПАРАМ ЧИСЛО" "ПАРАМ ЧИСЛО"
			 "'(' ПАРАМ '=' ЧИСЛО ')'" "'(' ПАРАМ ЧИСЛО ')'"
		  поэтому сделано:
		    ModelParameters : ... | ModelParameters '(' ModelParameter ')' ;
		    ModelParameter : ModelParm mbModelAssign Value ;
		    mbModelAssign : /*nothing*/ | '=' | ',' ;
		Для узлов оставлено
		- Node	: NodeName | ',' NodeName ;
		  то есть разделителем может быть запятая
		- дальнейшее добавление правил вызывает переполнение таблиц:
		  fatal error: clobber of a array, pos'n 1458, by -70, line 2579
		Итог дня:
			118/127 terminals, 240/250 nonterminals
			451/500 grammar rules, 803/1000 states !!!
			0 shift/reduce, 0 reduce/reduce conflicts reported
			240/250 working sets used
			memory: states,etc. 3856/5200, parser 931/4000

12.04		сделан пример TEST0412.CIR, обдумывание непонятностей
#--

15.04	0.99	в таблицы трансляций имен узлов и элементов выдаются не (только) пути
#79		  к определениям схем, где эти элементы встречаются, а (и) пути
		  _вызовов_ подсхем, где эти элементы встретились:
		  - структура StackCall, *stackCalls, *stackCallsTail
		  - в SHpass2.C:
		    - AddCallPath(Xxxx-имя)
		    - RemCallPath()
		    - OutCallPath(файл)
		  - эти функции добавлены в *.Y в обработке .SUBCKT при вызове
		    подсхемы (для Pass==2)
		  - в SHpass1.C вставлена OutCallPath() в:
		    - PrintNodesTransl()
		    - PrintElemsTransl()
		  - в *.Y добавлять AddCallPath(Xxxx-имя) надо не в обработке
		    .SUBCKT при вызове подсхемы, а в обработке элемента Xxxx
		    (для Pass==2)
		итак, можно приступать к генерации кода

16.04	1.00	чтобы иметь возможность давать предупреждения о несерьезных
#80		  ошибках и переходить на второй проход (генерацию кода):
		  в SHiofun.C:
		- MsgCompile() -> MsgCompileWarn() без ++cntErrors,
		  а MsgCompile(): MsgCompileWarn() с ++cntErrors
		- вызов собственной функции с переменным числом параметров
		  с помощью конструкции MsgCompileWarn( msgfmt, ... ) внутри
		  MsgCompile() возможен только в Borland, остальные компиляторы
		  конструкцию "..." в параметрах функции не поддерживают,
		  кроме того при форматном выводе в Borland традиционно возникают
		  глюки, поэтому в MsgCompile() все собирается в длинную строку
		  linebuffer, после чего выводится
		- введен префикс типа ошибки (*E*, *W*), для чего:
		  - MsgCompileWarn() -> static MsgCompileOut()
		  - в MsgCompileOut() добавлен параметр char *errprefix
		  - в MsgCompile() и MsgCompileWarn() в вызове MsgCompileOut()
		    задается этот префикс
		- MsgCompileOut() осталась с переменным числом параметров,
		  хотя это и не обязательно
		- между заголовком ошибки с именем файла и строкой-позицией
		  поставлен разделитель "\n\t"
		- этот же разделитель используется в *.Y:MsgAllowKeywords()
		  при выдаче многострочных сообщений в:
		  - ArExpr
		  убран вообще из:
		  - msgALLOWKEYWORD, msgALLOWFUNCTION, msgALLOWVOLTCURR1,
		    msgALLOW_V_C_FUN, msgALLOWVOLTCURR2,
		    msgEXPECTFUNNAME

17.04	1.01	введен счетчик предупреждений cntWarnings для MsgCompileWarn()
#81		*.Y: везде, где делается ADD_NODE_...() добавлено if(PassNo==1)
		SHpass2.H:
		- добавлен раздел физических констант
		- добавлен раздел умолчаний: def_NRMLEN=0.25
		*.Y:
		- pass2: предупреждения для игнорируемых элементов:
		  - полупроводниковый резистор
		  - полупроводниковый конденсатор
		- pass1: добавление элементов в список (сделано для всех):
		  list? = AddElem( list?, &cnt?, $1, circDefCurrent ); /* add to list */
		- введены переменные для параметров конструкций (Txxx)
		- перед началом любой Spice-строки обнулять абсолютно все
		  переменные для параметров конструкций (чтобы не плодить новые
		  нетерминалы):
                  попытка в правиле PrepElem добавить PrepElem вызвало разрушение
		  массивов Yacc для
			118/127 terminals, 241/250 nonterminals
			452/500 grammar rules, 803/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3858/5200, parser 936/4000

18.04	1.02	превышение количества правил в YACC дальше невозможно:
#82		- перекомпиляция YACC не помогла
		- надо сокращать кол-во правил:
		  - закомментарена возможность разделять узлы запятыми
			Node        /* Node with delimiters */
			 : NodeName
		                        ={ $<strptr>$ = $<strptr>1; }
			/* rem by ASB000418:
			 | ',' NodeName
		                        ={ $<strptr>$ = $<strptr>2; }
			*/
		новые изменения и дополнения от заказчика:
		- в .HB-операторе может отсутствовать параметр F2

20.04	1.03	! несмотря на небольшие сокращения в грамматике, вернуть
#83		  запятую между узлами не удается из-зи "clobber...",
		  поэтому нетерминал NodeName можно будет убрать при
		  необходимости для экономии
		SHpass2.H: добавлены новые константы
		S2H.cfg: добавлен новый параметр k_Diode_f0,
		- который также добавлен в таблицу параметров OptTab OptionsTab[],
		- по требованию заказчика инициализации параметров также
		  _уже_должны_ содержаться в этой таблице
		- а это значит, что отсутствие S2H.cfg не должно быть фатальной
		  ошибкой, а только давать предупреждение
		- сделаны MsgErrorCnt() - выдача в fileErr с подсчетом ошибок
		- и MsgWarningCnt() (зеркальная к MsgError()) - просто текст-
		  предупреждение в fileError с подсчетом количества предупреждений
		  без выдачи номера строки, позиции, строки и указателя
		- к сообщениям в этих двух функциях приписывать msgErrorPrefix =
		  "*ERROR*" и msgWarningPrefix = "*Warning*" соответственно
		- в конце проходов печатать еще и количество предупреждений
		- дублировать сообщения этих функций и в fileDebug
		- перед началом второго прохода cntWarnings = 0;
		- замена в соответствующих местах MsgError() на MsgErrorCnt()
		SHmain.C: открытие файла fileDebug поставлено раньше всех,
		  даже перед fileError

22.04	1.04	дополнения от заказчика:
#84		- не должны пропускаться узлы главной схемы в файле трансляции
		  имен - оказалось, что они пропускались при отсутствии ключа
		  '-1' в командной строке:
		  - в Pass1() функция PrintNodesTransl() вынесена из
		    if( Flags[flag1].value ){ ... }
	!	- нумерация хабала-узлов должна быть сплошной без пропусков:
		  при вызовах подсхем после SHpass1.C:RenameNodes() происходит
		  нерациональное использование номеров хабала-узлов (см. 0.88),
		  так как узлы-фактические параметры подставляются уже после
		  переименования узлов схемы, затирая уникальные номера,
		  поэтому при вызовах подсхем надо:
		  - вначале для всех узлов очистить их хабала-имена с помощью
		    новой функции ClrNodesName(),
		  - которая также должна узлу '0' присваивать хабала-имя '0   '
		  - подставить узлы-параметры
		  - переименовать оставшиеся элементы измененной функцией
		    RenameNodes(), чтобы она не трогала уже присвоенные
		    Хабала-имена
		  - ClrNodesName() вызвать и перед RenameNodes() для главной
		    цепи

23.04	1.05	упорядочивание кодов возврата в соответствии с требованиями
#85		  заказчика:
		- изменена структура положительного кода возврата - это не
		  только количество ошибок, но и информация о номере прохода
		  и предупреждениях - см. файл S2Hcall.txt
		- максимальное количество ошибок теперь должно втиснуться
		  в 4 бита, поэтому maxERRCOUNT = 15
		- подсчет количества предупреждений отдельно для первого и
		  второго проходов: cntWarnings1 и cntWarnings2
		- код возврата формируется функцией SHiofun.C:GetExitCode(),
		  который возвращается в main()
		обнаружен глюк: если строка начинается с описания элемента
		  недопустимого типа, это вызывает ошибку
		  "*ERROR* Not found .END in program" (msgERR_ENDNOTFND):
		- возникает в CheckCircBrackets() в правиле
		  ProgramBody : StatementList = {...}
		- это правилу возвращен вид, закомментаренный 06.04.00(0.92):
		  ProgramBody : StatementList _END
		- а правило ProgramBody : StatementList error - закомментарено
		- теперь
			118/127 terminals, 241/250 nonterminals
			451/500 grammar rules, 802/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3850/5200, parser 933/4000
		обнаружен еще глюк во втором проходе: если была попытка вызвать
		  несуществующую схему, то при вызове любой другой схемы дальше
		  вызывает ошибку о несоответствии количества параметров
		  (msgCNTPARMSUBCAL):
		- ошибочно cntParmSubCall, потому что вычисляется динамически
		  при поступлении узлов-фактических_параметров и в случае
		  ошибки в предыдущем вызове не очистилось
		- вставлено cntParmSubCall = 0 в правиле перед началом списка
		  узлов-фактических_параметров во втором проходе - не помогло !?
		- вставлено cntParmSubCall = 0 сразу после диагностики ошибки
		  о вызове несуществующей подсхемы
			MsgCompile( msgSUBCKTNOTEXIST, $4 );
		  - тоже не помогло - убрано
		- а надо делать еще и очистку самого списка параметров в
		  правиле CallSubCircuit /*Xxxx*/ : ...
		  перед списком узлов-фактических_параметров:
			/* free subcall parameters list: */
			DelParmSubCall( parmSubCall );
			parmSubCall = NULL;
			cntParmSubCall = 0;

24.04	1.06	генерация кода для Txxx - линия передач без потерь -> 'LIB0','LL0 '
#86		- перенесение действий из середины правила в конец (перед
		  _ENDOFSTMT_), чтобы:
		  - не порождать новые состояния (!)
		  - избежать занесения ошибочного элемента в список элементов
		    на первом проходе
		  - то же сделано и для UDRCLINE/*Uxxx*/
		  - в обработке списка параметров maybeLLTLoptions сделано
		    присвоение значений парам existXX и parmXX,
		    где XX = Z0, TD, F_FREQ, NL
		  - сообщение об ошибке в случае, если параметр повторился
		    и existXX:=FALSE
		  - перед генерацией проверить, набирается ли нужная комбинация
		    existXX'ов, если нет, то сообщение о том, что элемент
		    сгенерирован быть не может
		  - в HabElemPart() сделана часть /* T,O -> 'LIB0','LL0 ' */
	!	при ошибке в параметре ПАРАМ=ЗНАЧ указатель показывает
		  на первую лексему следующего параметра:
		  - причина - одновременное наличие конструкций
			Param '=' Value
		    и
			Param/*ID*/ '=' Value ',' Value ',' Value ',' Value
		    поэтому распознаватель принимает решение только после
		    прочтения следующей лексемы
		для уменьшения размера SHpars.Y макросы перенесены в SHpars.H
		генерация Txxx:
		- если NL не задан, то по умолчанию = 0.25 (def_NRMLEN)
		- если ошибки в параметрах - это "ошибки", то сообщение о
		  невозможности генерации кода - предупреждение
		- неверно выводится сообщение "Illegal option '<?>'":
		  - надо OptionStartKeyword заменить на Identifier
		замена OptionStartKeyword на Identifier везде, где еще оставалось
		  с удалением самого правила для OptionStartKeyword : Identifier ;

25.04	1.07	генерация кода для Oxxx - линия передач с потерями -> 'LIB0', 'LL0 '
#87		  MkElemOxxx():
		- на 2 проходе перед генерацией должно выполняться
                     if( !isSubDefBody /*subcall in main circuit*/ ||
                        ( isSubDefBody && isSubCall && (circCall == circDefCurrent) ) )
		- поиск модели в текущей схеме и во всех объемлющих
		- проверка типа модели
		- сделана SHpass1.C:GetModelParm()
		- поиск необходимых параметров в модели:
		  - есть ли такой параметр
		  - проверка, имеет ли значение
		  - проверка параметров на допустимость
		- вычисление хабала-параметров и генерация кода
		- если L или C == 0 учтено уже в условии L>0, R>0

03.05	1.08	двойное определение msgPARMILLVALUE - исправлено
#88		начат файл ERRDIAGS.TXT с описанием диагностируемых ошибок
		  при генерации элементов
		для MkElemOxxx(): избежать деление на 0:
		  if( C != 0 ) parmZ0 = sqrt( L / C );
		  (на всякий случай, потому что в макросах GETANDCHKPARM...()
		  при ошибке в параметре делается return из функции генерации)

04.05	1.09	для диодов Шоттки добавлен параметр Rsmin = 1.0:
#89		- в S2H.cfg
		- в SHconfig.C
		SHpass2.H: изменены макросы GETANDCHKPARMxx0 (где xx - eq, gt)
		  на GETANDCHKPARMxxVAL(val, ...)
		генерация кода для Dxxx (диодов Шоттки)
		- *.Y - pass2 часть
		- existDiodArea, parmDiodArea
		- проверка, не повторяется ли параметр AREA
		- проверка правильности AREA (>0, в ТЗ: !=0)
		SHpass2.H: добавлены макросы GETDEFCHKPARMxxVAL (где xx - eq, gt),
		  при отсутствии параметра модели дающие не сообщение об ошибке,
		  а подставляющие значение по умолчанию
		- MkElemDxxx( ..., parmDiodArea):
		  - проверка существования модели
		  - проверка типа модели
		  - ввод, проверка и подстановка по умолчанию параметров модели
		  - расчеты
		  - вывод &ELEM
		- в HabElemPart() добавлена сборка диодов Шоттки:
		  - fi, f0 использовать для генерации &TYP IT='VD  ', 'SCHT'
		- еще одна ошибка-сообщение: параметр моделей VJ должен быть
		  одинаков для всех диодов Шоттки в схеме
		неясно (нет в ТЗ), как вычислять параметры U0 и DU для хабала-
		  диода Шоттки - из S2H.CFG оказывается

06.05	1.10	при перекомпиляции с Борланда на Гну/МС-С обнаружились глюки
#90		  которые Борланд пропускал:
		- в SHmsgEN.H в #define было две закрывающие кавычки
		- SHpass2.C:AddCallPath() (Win32 здесь падает без предупреждений):
		  присваивание stackCallsTail->next=... при stackCallsTail==NULL
		  - сделана проверка
		сообщение msgNOTEQPARMVJ
		  Model parameter VJ must be equal for all diodes Schottky:
		заменено на
		  Model parameter VJ=%g must be equal to same parameter VJ=%g
						for previous diodes Schottky

29.05	1.11	Косметические изменения (у заказчика хабалятор задышал):
#91		- после директивы "&SERV .../" сразу должна следовать пустая
		  директива "&CIRCOM /": SHpass1.C:OutHabCIRCOM()
		- в директиве &TYP параметры должны задаваться не PARAM =...,
		  а P=... - SHpass2.C:HabTYPout()
		- вместо &FREQ должно быть &FREQU (название директивы)
		добален конфигурационный параметр (для генерации Vxxx)
		  R_emf_i=0.1 - внутреннее сопротивление источника напряжения:
		- в S2H.CFG
		- во внутреннюю таблицу OptionsTab[]

31.05	1.12	Попытка переноса хабалятора на FreeBSD:
#91		- SRC/mk (запуск "./mk"):
		  так как в DOS-тексте в конце строки добавляется лишний '^M',
		  в командах UNIXа он воспринимается как символ, внося ошибки,
		  поэтому в скриптах shell/make в конце строки лучше ставить
		  " " или ";"
		- переименование файлов исходников в соответствии с регистром:
		  ./ux_ren
		- одного переименования мало - надо удалять в исходниках '^M',
		  для чего сделана програмка DOS2IX
		- теперь в ./ux_ren вместо переименования используется DOS2IX
		- <conio.h> не существует (исп. в SHconfig.H)
		- makefile.bsd
	?!	- во FreeBSD YACCе вклинивание y.tab.h производится после
		  инициализации KeysTab KeywordsTab[], а надо после
		  - перестановка KeywordsTab[] в заголовке *.Y прямо к %%
		    раздела правил не помогла
		  - пришлось вставить в начале *.Y:
			# if defined(BSD)
			#  include   "y.tab.h"
			# endif
		    теперь компилер не ругается, хотя константы определяются
		    дважды, зато двойное определение
			union YYSTYPE yylval
		    он не перенес - убрано
		на этом работы приостановлены

01.06	1.13	продолжение:
#92	1.14	- один из способов решения проблемы с YACCом (непереносимый) -
		  использовать результаты работы своего старого YACCа - файл
		  ../SHpars.C
		- с Lex'ом тоже проблемы, пока использую ../SHlpars.C
		- а в ../SHlpars.C местный компилер не схавал древний С-стиль:
			yyback(p, m) int *p; {...}
			yyinput() {...>
			yyoutput(c) int c; {...}
			yyunput(c) int c; {...}
		  ему захотелось такого:
			yyback( int *p, int m ) {...}
			yyinput( void ) {...>
			yyoutput( int c ) {...}
			yyunput( int c ) {...}
		  к счастью, это можно исправить в NCFORM.C
		- в файлах Lex-библиотеки LEXLIB/allprint.c,reject.c,yyless.c,
		  yywrap.c в конце надо убрать DOSовский '^Z'
		- все скомпилировалось, но при сборке не нашлись модули:
		  sqrt()	в SHpass2
			- кроме #include <math.h> надо подключать мат. биб-ку
			  libm.a ключом -lm
		  getch()	в SHiofun
			- делаем (для BSD): #define getch() getchar()
		  searchpath()	в SHmain
		  coreleft()	в SHpass1, SHpass2
			- экранируем их в SHcommon.H
		  strupr()	в SHiofun, SHlpars, SHpars
			- в <string.h> такой не оказалось, делаем свою
			  в SHcommon.H:
			    #if defined(BSD)
			    # define  strupr( s ) while( *s++ ) *s = toupper(*s)
			    #endif
			  но так нельзя, если s - не указатель, поэтому
			    # define  strupr( s ) \
				{ char *p; p = s; while( *p++ ) *p = toupper(*p); }
			  так тоже нельзя, так как strupr() встречается как
			    параметр в вызове функции, поэтому в SHiofun.C
			    добавлена функция 
				#if defined(BSD)
				    char *
				strupr(
				    char *str
				){
				    char *ptr = str;
				    while( *ptr++ ) *ptr = toupper(*ptr);
				    return str;
				}/*strupr()*/
				#endif
		скомпилировалось, но при тестировании выяснилось, что есть
		  проблемы с плавающей запятой или с форматным выводом
		  (везде использовалось %g вместо %f или %e)
		- с форматным выводом все в порядке - проверено
		- может библиотеку какую надо или ключ компилятору?
		- нет, все работает, это в LookupScale() не определяется
		  правильно суффикс-множитель, вероятно из-за strupr() - да
		  из-за глупой ошибки не поднимался регистр первой буквы
		теперь все работает, все выходные файлы совпали с борландовским
		  хабалятором, есть лишь маленькое отличие в _отладочном_ выводе
		  указателей по формату %p: у Борланда - 0000:0000, здесь -
		  0x00000000, в VisC++ и GNU_C/W32 - 00000000,
		  зато вывод плавающих чисел с экспонентой - как у Борланда -
		  2 знака в экспоненте: ...e-00, а не ...e-000 как у VisC++ и
		  GNU_C/W32

02.06	1.15	переделки по требованию заказчика (TZ0530):
#93		Линии без потерь Txxx:
		  - в выходном файле должно указываться 2 параметра: Z0, Length - см. di2.readme:
			t1  2 0 3 0 z0=50 f=100MEG NL=0.5 превращается в
			&ELEM NE='T1  ', KNOT=2, 3, 0, 0, PAR=1.66782e-017 /
			а надо 2 параметра: PAR=50, 1.66782e-017
		  - в формулах вместо деления должно быть умножение:
			Length= TD*_c		- ! вместо TD/_c
		    или
			Length= (1/F)*NL*_c	- ! вместо (1/F)*NL/_c
		    теперь в приведенный пример транслируется в
			 &ELEM NE='T1  ', KNOT=2, 3, 0, 0, PAR=50, 1.49896 /
		- Линии с потерями Oxxx (в SHpass2.C:MkElemOxxx()):
		  - Если R или G не заданы (в модели для Oxxx) - предупредить,
		    установитm их =0 и продолжить работу
		  - если R и/или G !=0 - так же
		  - для этого надо макрос GETANDCHKPARMeqVAL() заменить на
		    GETORSETDEFPARMeqVAL()
		в диагностике неверного идентификатора функции в правиле
		  ArExpr : Identifier '(' ArExpr ')' /* function or OutVar */
		  убрано заворачивание (слишком) длинной строки-сообщения (>200
		  символов) для того, чтобы привести вывод сообщений к единому
		  4-строчному виду:
			1 - код (сейчас - тип) ошибки, файл, строка, позиция
			2 - текст сообщения (может быть длиннее одной строки)
			3 - строка спайс-исходника, в котором была найдена ошибка
			4 - указатель на ошибочную лексему "^" в предыдущей строке
		  (арифметические выражения встречаются в NLDS Bxxx)

03.06	1.16	убрано (лишнее) правило:		
#94			StatementItem
			 : _END ={ cnt_END++; return cntErrors; }
		  так как есть его замена
			ProgramBody : StatementList _END ;
		  теперь
			118/127 terminals, 241/250 nonterminals
			450/500 grammar rules, 801/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3843/5200, parser 934/4000
		  - проверено, что зацикливаний в программах без .END не возникает
		другой способ решения проблемы с (BSD)YACCом (переносимый) -
		  SHpars.Y делится на две части: собственно SHpars.Y и
		  SHparsY.C, содержащий злополучную KeysTab KeywordsTab[]
		  и весь хвост файла SHpars.Y, правда теперь все локальные
		  функции становятся глобальными
		! кроме того, на ~300 строк уменьшится становящийся критически
		  большим файл SHpars.Y - уже почти 3000 строк
		- в связи с этим сделаны дополнения в makefile'ах для:
		  - bC++
		  - gnuC++
		  - visC++: долго боролся с "глюком" - make упорно не видел
		      SHpars.Y - оказалось, надо работать с makefile.nma,
		      а не makefile.msc ! Во избежание повторения подобных
		      ошибок вариант с MS C v.6 ликвидирован
		  - freeBSD - отложено

12.06	1.17	проверено и под FreeBSD - собирается
#95		makefile.gnu:
		- вызовы DOS-комманд через command /c ..., так как у заказчика
		  гнуMake почему-то не может выполнить команды вроде copy, del
		  пытаясь для этого вместо %COMSPEC%=command.com запускать
		  что-то свое, выдавая диагностику о невозможности запустить
		  какой-то процесс "(null)"
		- заменено в DOS-командах '\' на '\\' (тоже из-за проблем у
		  заказчика)
		Ixxx:
		- проблема: в Vxxx, Ixxx одному спайс-элементу может
		  соответствовать несколько хабала-элементов,
		  т.о. вместо группового переименования элементов в (под)схеме
		    SHpass1.C:RenameElems( /* function for rename elements in list */
		      ElemList *listElem, SubCirc *circuit, int renCntElem )
		  прийдется делать это для одного элемента многократно перед
		  формированием каждой составляющей источника:
		  добавлена
		    SHpass1.C:Rename1elem( char *spicename, ... )
		  раньше переименование делалось только:
		  - в конце первого прохода для главной схемы:
		    RenameAllElems( NULL );
		  - перед каждым вызовом подсхемы (при обработке элемента Xxxx):
		    RenameAllElems( circCall );
		- SHpass2.C:MkElemIxxx():
		  - с трудом вспомнилось, что все элементы лежат в одном списке
		    list?, а не делятся по подсхемам
		  - параметры Gi, F, Fi, Jm будем вычислять вне этой функции
		    при каждом (возможно повторяющемся) появлении DC, DISTOF1/2
		- *.Y: при входе в правила OptDCfree или VoltCurrOption надо
		  знать, что обрабатывается: Ixxx или Vxxx, для чего введены
		  признаки isIxxx и isVxxx, =FALSE всегда, но устанавливающиеся
		  в TRUE при входе в обработку элемента Ixxx или Vxxx и
		  _обязательно_ :=FALSE при выходе из правила Ixxx или Vxxx,
	!	  особенно в случае ошибки, пока повезло:
			118/127 terminals, 241/250 nonterminals
			450/500 grammar rules, 801/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3843/5200, parser 934/4000

14.06	1.18	продолжение Ixxx:
#96		- перед вызовом MkElemIxxx() необходимо формировать параметры
		  Gi, F, Fi, Jm для каждого случая отдельно:
                  - IxxxParmFromDC( &Gi, &F, &Fi, &Jm, DC-параметр)
                  - IxxxParmFromDISTOF( &Gi, &F, &Fi, &Jm,
			номерDISTOF1или2, 1-й-параметр, 2-й-параметр)
		  - *.Y: для вычисления F в IxxxParmFromDISTOF() запоминаются
		    extern double parm_HB_F1, parm_HB_F2 для последней директивы
		    .HB из входного потока

15.06	1.19	продолжение Ixxx: *.Y:
#97		- вычисление параметров Gi, F, Fi, Jm для каждого конкретного
		  случая
		- введение признака того, что текущая опция обрабатывается,
		  а не игнорируется (isIVxxxOpt), если ==TRUE (для DC, DISTOF1/2),
                  :=FALSE при выходе из обработки опции, при этом:
			118/127 terminals, 241/250 nonterminals
			450/500 grammar rules, 801/850 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3843/5200, parser 934/4000
		- текущее имя элемента: IxxxName, VxxxName
		- занесение в 'linebuffer' списка узлов в хабала-виде в самом
		  начале обработки правила для I/Vxxx
		- генерация кода осуществляется после полного разбора текущей
		  опции DC, DISTOF1/2, используя сохраненные имя элемента
		  IxxxName и список хабала-узлов, сохраненный в 'linebuffer'
		  в последовательности:
			renI = Rename1elem( IxxxName, listI, circCall, renI );
			PrintElemsTransl( IxxxName, circDefCurrent, listI );
			MkElemIxxx( IxxxName, linebuffer, ... );
	?	- надеюсь, что текущая подсхема - circCall
		! если переименование элемента I/Vxxx и вывод нового имени в
		  файл трансляции имен происходит здесь, то печать трансляции
		  узлов здесь не происходит (здесь новые узлы не появляются),
		  а печать трансляции узлов делается в конце первого прохода
		  в SHpass1.C:
			PrintNodesTransl( NULL/*MainCircuit*/, listNodesMain );
		  и при вызове подсхемы Xxxx для локальных узлов в SHpars.Y:
			PrintNodesTransl( circCall, circCall->circnodlist );
		  пока ситуации с появлением новых узлов (которых не в Спайс-
		  программе не возникало)
		- генерация кода указанным образом делается в 3-х местах
		  совершенно одинаково, поэтому вынесена в SHpars.H в виде
		  макроса

16.06	1.20	отладка Ixxx:
#98		? генерация пока не происходит
		- на этапе генерации вместо DISTOF2 было DISTOF1
		- в HabElemPart() (извлечение и сортировка элементов из
		  временного файла) забыл вставить часть для Ixxx, Vxxx
		- SHpass2.C:HabTYPout(): для случая пустого параметра 'param'
		  'P=...' не печатать
		? в файле трансляции имен для элементов Ixxx подсхем появляется
		  мусор в виде спайс-имени _без_ хабала-имени для
		  path_of_subcall="/" такой элемент идет в паре с любым элементом
		  подсхемы, повторяя его параметры и, кроме того,
		  во временном файле появляется
			&ELEM NE='    ', KNOT=(null), (null), PAR=0, 0, 0, 5.5 /
		  - это пережиток обработки подсхем - попытка генерации элемента
		    при анализе тела подсхемы, а не только при вызове -
		    в макрос MAKEELEM_IVxxx перед генерацией добавлено
		    if( !isSubDefBody /*subcall in main circuit*/ ||
		        ( isSubDefBody && isSubCall && (circCall == circDefCurrent) ) )

	1.21	начата генерация Vxxx:
		- добавления в макрос SHpars.H:MAKEELEM_IVxxx для Vxxx
		- IxxxParmFromD...() -> IVxxxParmFromD...()
		- SHpass2.C:MkElemVxxx() = MkElemIxxx(), только listI->listV
		- добавление в HabElemPart(): к 'J   '-типу относятся не только
		  "&ELEM NE='I...'", но и "&ELEM NE='V...'"
		- обнаружены пропуски номеров хабала-элементов как для Ixxx,
		  так и для Vxxx, поэтому из группового переименования эл-тов
		  RenameAllElems() убрано переименование всех Ixxx и Vxxx
		- исправлена ошибка вычислений Fi в IVxxxParmFromDISTOF()
		- изменение формул расчета Gi, F, Fi, Jm для Vxxx:
		  - в *.Y перед вызовом функций IVxxxParmFromD...() при isVxxx
		    брать Ri из хабала-параметров:
			GetConfOption( "Ri", &isint, &Ri/*dblparm*/, &longparm );
	!	! использованию Борланда3.1 пришел конец - он уже не может
		  переварить результаты работы YACC'a:
		  Error shpars.y 2877: Compiler table limit exceeded in function yyparse
		- переходим на гнуС - пока нормально
		- в макросе MAKEELEM_IVxxx /* generate code for I/Vxxx */
		  после генерации элемента-источника профилактически обнуляются
		  хабала-параметры:
			IVxxxGi = IVxxxF = IVxxxFi = IVxxxJm = 0.0;

17.06	1.22	неожиданно под Win98SE перестало работать правило в makefile.gnu:
#99			$(LEXCNV) <lexyy.c >$(WRKDIR)\\SHlpars.c
		  пришлось заменить на
			$(LEXCNV) <lexyy.c >$(WRKDIR)\SHlpars.c
		продолжение Vxxx:
		- убрано вычисление Ri везде для Vxxx, а вместо этого введена
		  глобальная переменная VxxxRi
		- для каждого Vxxx, преобразованного в группу элементов Ixxx,
		  добавляется Rxxx с сопротивлением, равным Ri
		  этот резистор добавляется всегда, даже если Vxxx ни во что
		  не преобразовался
		- обязательное переименование данного Ri, имеющего первоначально
		  имя "R"+"Vxxx"
		- переименование "RVxxx"-резисторов специально производить не
		  надо, так как это уже делается после первого прохода для
		  главной схемы и при вызове подсхем
	!	из-за добавления резисторов в конце первого проходе неверно
		  выдается статистика для _определений_ элементов R - их больше
		  реального количества на число Vxxx-элементов
		в Pass1Statistic() добавлена выдача статистики для определений
		  _всех_ элементов, а не только R, L, C

23.06	1.23	уточнение формулы расчета Fi для Vxxx:
#100		- в общем случае:
			Vxx N+ N- ... DISTOF1 0.5 _фаза1 DISTOF2 2.2 _фаза2
		  транслируется в:
			IVxx#3 N+ N- DISTOF1 0.5/Ri _фаза1-90
			IVxx#4 N+ N- DISTOF2 2.2/Ri _фаза2-90

24.06	1.24	изменения, связанные с формированием кодов ошибок и нового
#101		  кода возврата:
		- проходы нумеруются: 0/*pre-pass*/, 1, 2, 3/*post-pass*/
		- замена префиксов ошибок в сообщениях-предупреждениях:
		  "*FATAL*" на "#FE", "*ERROR*" на "#ER", "*Warning*" на "#W"
		- после первых трех символов идет номер прохода и тире:
		  - "#FE0-"		в SHiofun.C:MsgErrorFatal()
		  - "#ER1-", "Wx2-"	в SHiofun.C:MsgCompileOut()
		- попутно в MsgCompileOut() исправлены все явные выводы
		  в fileErr "fprintf( fileErr, ..." на "MsgError( ..."
		- добавление кода/номера/идентификатора ошибки MsgErrorFatal():
		  - исправление всех! сообщений в SHmsgEN.H для MsgErrorFatal():
		    SHmain.C:	msgNOFLAGPARM, msgNOINPFNAME, msgNOOUTFNAME
				msgERRDEBCREAT, msgERRERRCREAT, msgERRCNFOPEN,
				msgERRINPOPEN, msgERRTMPCREAT, msgERROUTCREAT,
				msgERRFNODCREAT, msgERRFELECREAT, msgERRINPREOPN
		    SHiofun.C:	msgABORTBYUSER, msgFERR_ENDNOTFND
		    SHpars.Y:	msgPARSEREXIT, msgERRMEMALLOC
		    SHpars.H:	msgFAILADDNODE
		    SHpass1.C:	msgRENNODESFAIL, msgCIRCNAMETOOLONG,
				msgERRMEMALLOC1, msgRENELEMFAIL
		    SHpass2.C:	msgERRMEMALLOC2, msgERRTMPCREAT, msgERRSUBCIRPLACE
		  - пока всем фатальным ошибкам присвоен код "9000"
		- попутно исправлен глюк в MsgErrorFatal() - неверный вывод
		  переменного количества параметров в несколько файлов -
		  вначале все загоняется в строку linebuffer
		- SHexcode.H: введение 7 классов предупреждений:
		  - warn1_INFO		'I'	информационное, например
						при отсутствии параметра взято
						значение по умолчанию
		  - warn2_RESERV	'2'	
		  - warn3_CONFLICT	'C'	конфликт в параметрах и т.п.
		  - warn4_RESERV	'4'
		  - warn5_BREAK		'B'	прерывание генерации элемента
		  - warn6_RESERV	'6'
		  - warn7_RESERV	'7'
		- счетчики общего количества предупреждений на каждом из проходов
		  cntWarnings1 и cntWarnings2 оставлены, но они будут использоваться
		  только для статистики, но не для формирования кода возврата
		- введение счетчика для каждого класса предупреждений
		  и обнуление их вместе с дугими счетчиками ошибок
		- MsgCompileOut(): добавление параметра - уровня предупреждения,
		  который для MsgCompileWarn() будет иметь значение,
		  а для MsgCompile() быдет пустым ""
		- также добавлен расширенный префикс в
		  - MsgWarningCnt()
		  - MsgErrorCnt()
		- попутно в этих функциях исправлены все явные выводы
		  в fileErr "fprintf( fileErr, ..." на "MsgError( ..."
		  и в fileDebug "fprintf( fileDebug, ..." на "MsgDebug( ..."
		- добавление в MsgWarningCnt() параметра warnlevel
		- исправление всех вызовов MsgWarningCnt() с добавлением уровня
		  предупреждения:
		  - SHmain.C - отсутствие конфигурационного файла S2H.CFG -
		    информационное предупреждение
		- MsgCompileWarn():
		  - добавление параметра - класса предупреждения
		  - увеличение счетчика для соответствующего класса предупреждений
		  - исправление всех вызовов MsgCompileWarn():
		    SHpars.Y:	msgNotProcSemiR(Rxxx)	- warn1_INFO
				msgNotProcSemiC(Cxxx)	- warn1_INFO
				msgNOTGENELEM(Oxxx)	- warn5_BREAK
				msgNOTGENILLPARM(Txxx)	- warn3_CONFLICT
				msgPARMILLVALUE(Dxxx)	- warn3_CONFLICT
				msgNOTGENELEM(Dxxx)	- warn5_BREAK
		    SHpass2.H:	в макросах - параметр отсутствует, взято значение
				по умолчанию - warn1_INFO
		- сделана общая SHiofun.C:MsgHeader(), формирующая префикс
		  ошибки "#EXП-" для функций MsgWarningCnt(), MsgErrorCnt(),
		  MsgCompileOut(), MsgErrorFatal()
		- если в MsgErrorFatal() отсутствуют второй и третий параметры,
		  то это просто аварийный выход без сообщений, но с кодом
		  возврата (сообщение msgFATALHIDDEN)

25.06	1.25	продолжение формирования кодов ошибок:
#102		- добавление параметра-кода ошибки в следующие функции с
		  соответствующей коррекцией сообщений в SHmsgEN.H:
		  - MsgWarningCnt():
			SHmain.C:	msgWARNCNFOPEN		- "1001"
		  - MsgErrorCnt():
			SHLPARS.L:	msgERRINCLOPEN		- "4010"
			SHPARS.H, SHPARSY.C:
					msgERR_ENDNOTFND	- "4020"
				(в SHiofun.C:MsgCompileOut() это сообщение
				 о _фатальной_ ошибке, поэтому для MsgCompileOut()
				 оно переименовано в msgFERR_ENDNOTFND)
			SHPARS.Y:	msgNEED_END		- "4030"
			SHPARSY.C:	msgERR_SUBCKTCNT	- "4040"
		  - MsgCompileWarn():
		    SHpass2.H:	в макросах:
				msgPARMVALSETDEF	- "2001"
				msgPARMNOVALSETDEF	- "2002"
				msgPARMILLVALSETDEF	- "2003"
		    SHpars.Y:	msgNotProcSemiR(Rxxx)	- "2010"
				msgNotProcSemiC(Cxxx)	- "2020"
				msgPARMILLVALUE(Dxxx)	- "2091" |
				msgNOTGENILLPARM(Txxx)	- "2092" |
				msgNOTGENELEM(Oxxx,Dxxx)- "2099" |
				(три последних предупреждения будут общими
				 для многих элементов)
	!	  - MsgCompile(): очень много сообщений - будет сделано позже,
		    но надо иметь в виду, что если MsgCompile() использует
		    общие с предыдущими функциями сообщения, то они будут
		    отображаться неверно

26.06	1.26	продолжение формирования кодов ошибок:
#103		- добавление параметра-кода ошибки в следующие функции с
		  соответствующей коррекцией сообщений в SHmsgEN.H:
		  - SHparsY.*:MsgAllowKeywords() - использует MsgCompile(),
		    поэтому тоже необходимо добавить лишний параметр и заменить
		    сообщения:
		    SHpars.Y:
			msgALLOWKEYWORD	- "5001"
		  - MsgCompile():
		    добавить параметр в SHiofun.*
		    SHLPARS.L:
			msgILLKEYWORD		- "5401"
			msgILLSYMB		- "5402"
			msgILLTOKEN		- "5403"
			msgNOINCLFILE		- "5404"
			msgMAXINCLNEST		- "5405"
			msgINCFILNOTFND		- "5406"
			msgERRINCLOPEN		- "4010" - уже было
		    SHPASS1.C:
			msgELEMNAMEEXIST	- "5101"
			msgDEFCIRCEXIST		- "5102"
		    SHPASS2.H:
			msgPARMNEEDVALUE	- "5201"
			msgMODPARMNOTFND	- "5202"
			msgMODLPARMILLVAL	- "5203"
		    SHPASS2.C:
			msgMODELNOTFOUND	- "5204"
			msgILLMODELTYPE		- "5205"
			msgNOTEQPARMVJ		- "5206"
		    SHPARS.Y:
				обшие:
			msgNEED_END		- "4030" - уже было
			msgERRSTMT		- "5002"
			msgERR_MODEL		- "5003"
			msgMODELPARMEXIST	- "5004"
			msgERR_SUBCKT		- "5005"
			msgCIRCDEFEXIST		- "5006"
			msgERR_ENDS		- "5007"
			msgCIRCNOTIN1FILE	- "5008"
			msgSUBCIRCPARM0		- "5009"
			msgERR_SUBCKTSTMT	- "5010"
			msgERRSUBCALL		- "5011"
			msgSUBCKTNOTEXIST	- "5012"
			msgCNTPARMSUBCAL	- "5013"
			msgPARMSETSUBCAL	- "5014"
				в элементах схем:
			msgERRINDUCTOR		- "5501"
			msgERRCOUPINDUC		- "5502"
			msgNEEDINDUCTOR		- "5503"
			msgERRRESISTOR		- "5504"
			msgERRCAPACITOR		- "5505"
			msgERRVOLTAGE		- "5506"
			msgERRCURRENT		- "5507"
			msgERRLVCVS		- "5521"
			msgERRLVCCS		- "5522"
			msgERRLCCCS		- "5523"
			msgERRLCCVS		- "5524"
			msgERRNLDS		- "5525"
			msgUNCLOSEDAREXPR	- "5531"
			msgERRAREXPR		- "5532"
			msgRIGHTBRKREQ		- "5533"
			msgLEFTBRKREQ		- "5534" - не исп.
			msgERRVSWITCH		- "5541"
			msgERRISWITCH		- "5542"
			msgERRLLTLINE		- "5543"
			msgERRLTLINE		- "5544"
			msgERRUDRCLINE		- "5545"
			msgERRDIODE		- "5551"
			msgDIODAREAAGAIN	- "5552"
			msgERRTRANSISTOR	- "5553"
			msgERRJFET		- "5554"
			msgERRMESFET		- "5555"
			msgERRMOSFET		- "5556"
				общие в элементах схем:
			msgILLOPTION		- "5591"
			msgNEEDVOLTAGE		- "5592"
			msgNEEDVOLTCURR		- "5693"
			msgTOOMUCHPARM		- "5594"
			msgTOOFEWPARM		- "5595"
			msgPARMILLVALUE		- "2091" - уже используется
			в предупреждениях, заменено в *.Y в 4-х местах на
			msgERPARMILLVALUE	- "5596"
			msgPARMALREADYDEF	- "5597"
				в элементах управления:
			msgERR_CONTROL		- "5601"
			msgERR_LET		- "5602"
			msgERR_ALTER		- "5603"
			msgERR_WRITE		- "5604"
			msgERR_OPTIONS		- "5605"
			msgERR_NODESET		- "5606"
			msgERR_IC		- "5607"
			msgERR_AC		- "5608"
			msgERR_DC		- "5609"
			msgERR_DISTO		- "5610"
			msgERR_NOISE		- "5611"
			msgERR_OP		- "5612"
			msgERR_PZ		- "5613"
			msgERR_SENS		- "5614"
			msgERR_TF		- "5615"
			msgERR_TRAN		- "5616"
			msgERR_TLINE		- "5617"
			msgERR_WIDTH		- "5618"
			msgERR_SAVE		- "5631"
			msgERR_PRINT		- "5632"
			msgERR_PLOT		- "5633"
			msgERR_FOUR		- "5634"
				в хабала-операторах:
			msgERR_HB		- "5681"
			msgHBALREADYEXIST	- "5682"
			msgERR_HB_OPTIONS	- "5683"
			msgUNKNWN_HB_OPT	- "5684"
				в элементах управления:
			msgNOTRESERVKEY		- "5691"
		- в ERRDIAGS.TXT перечислены ошибки для новых элементов I и Vxxx

27.07	1.27	проверка оставшихся сообщений из SHmsgEN.H, к которым не
#104		  добавился код сообщения:
		- в SHmsgEN.H собраны _все_ сообщения, используемые программой,
		  а не только диагностические, в том числе и часть отладочных
		- msgUNKNOWNFLAG - используется только MsgConsole(), в файлы
			диагностики не попадает
		- обнаружены пропущенные сообщения для MsgErrorFatal(), поэтому
		  сделана проверка:
		  SHIOFUN.C:
			msgERRINPOPEN		- "9012"
			msgERRINPREOPN		- "9013" +
			msgFERR_ENDNOTFND	- "9022"
			msgABORTBYUSER		- "9911"
			msgINPFAIL		! "9025" - было пропушено
		  SHCOMMON.H:
			msgOUTFAIL		! "9026" - было пропушено
		  SHMAIN.C:
			msgNOFLAGPARM		- "9001"
			msgNOINPFNAME		- "9002"
			msgNOOUTFNAME		- "9003"
			msgERRDEBCREAT		- "9018"
			msgERRERRCREAT		- "9017"
			msgERRCNFOPEN		- "9011"
			msgERRINPOPEN		- "9012" +
			msgERRTMPCREAT		- "9019" +
			msgERROUTCREAT		- "9014"
			msgERRFNODCREAT		- "9015"
			msgERRFELECREAT		- "9016"
			msgERRINPREOPN		- "9013" +
			msgFATALHIDDEN("")	- ""  - пустое для аварийного
						  выхода без сообщений вообще
		  SHLPARS.L:
			msgERRMEMALLOC		- "9099"
			msgMAXINCLNEST		- "5405" - есть простая ошибка
			msgFEMAXINCLNEST	! "9020" - добавлено
		  SHPARS.H:
			msgFAILADDNODE		- "9021"
		  SHPARS.Y:
			msgPARSEREXIT		- "9023"
			msgERRMEMALLOC		- "9099" +
		  SHPASS1.C:
			msgRENNODESFAIL		- "9102"
			msgCIRCNAMETOOLONG	- "9103"
			msgERRMEMALLOC1		- "9199"
			msgRENELEMFAIL		- "9101"
		  SHPASS2.C:
			msgERRMEMALLOC2		- "9299"
			msgERRTMPCREAT		- "9019" +
			msgERRSUBCIRPLACE	- "9201"
			msgERRCIRCOPEN		! "9202" - было пропушено
			msgERRCIRCFAIL		! "9203" - было пропушено
		- найдена пропущенная простая ошибка:
		  SHLPARS.L:
			msgERRINCLRETN		! "5407" - было пропушено
		- просмотр (глазами) файла SHmsgEN.H (закомментаренные,
		  потерянные сообщения):
		  ссылка не обнаружена:
			msgERRCLOSEALL		- "9029" - удалено из SHiofun.C
		  SHconfig.C:
			msgUNKNWNOPTION		! "5685" - ошибка, а не предупр.
		  SHpars.Y:
			msgERRINPROG		- "5xxx" - когда-то удалено
			msgILLFUNCTION		- "5xxx" - когда-то удалено
			msgEXPECTFUNNAME	! "5590" - для MsgAllowKeywords()
			msgALLOWFUNCTION	- "5xxx"
			msgALLOWVOLTCURR1	- "5xxx"
			msgALLOW_V_C_FUN	! "5535" - для MsgAllowKeywords()
			msgALLOWVOLTCURR2	! "5536" - для MsgAllowKeywords()
			msgILLPRNTYPE		! "5537" - для MsgAllowKeywords()
			msgNotProcElement	- "5xxx"
	?	! останется нерешенной проблема (случайного) совпадения кодов
		  разных ошибок и присвоения новых при их добавлении в
		  SHmsgEN.H

28.06	1.28	изменение кода возврата хабалятора в соответствии с
#105		  введенными классами предупреждений:
		- переделка тестовых *.BAT-файлов в соответствии с новым кодом
		  возврата: нормальным завершением считаются коды возврата 0
		  (ни ошибок, ни предупреждений) и 1 (было некоторое
		  количество информационных предупреждений)
		- описание классов предупреждений в SH_CALL.TXT как составной части
		  положительного кода возврата
		- SHiofun.C:GetExitCode():
		  - если же были ошибки на каком-то из прожодов, то эдесь
		    формируется фатальная ошибка "Error(s) in pass #..."
		    и тут же запускается с помощью MsgErrorFatal()
		  - SHexcode.H: exitERRORSONPASS1,2
		  - SHmsgEN.H: msgERRORSONPASS1,2
		  - новые коды возврата фатальных ошибок:
			msgERRORSONPASS1	- "9901"
			msgERRORSONPASS2	- "9902"
		  - если есть только предупреждения - формируется положительный
		    код возврата: |0|W7|W6|W5|W4|W3|W2|W1|W0|
		в обработке диодов Шоттки обнаружился глюк - выдача предупреждения
		  msgNOTEQPARMVJ (SHpass2.C) где не надо:
		  Model parameter VJ=1 must be equal to same parameter VJ=1
			for previous diodes Schottky:
		- была ошибка if( exist_fi ){ сообщение msgNOTEQPARMVJ } вместо
		    if( exist_fi && spice_VJ != glb_Diode_fi ){ ... }

02.07	1.29	устранение ошибок в генерации кода согласно TZ0626:
#106	?	? в присланном примере diod1.ckt неверно описана модель 'dio'
		- неверно обрабатываются отрицательные целые в .hb ... ,
		  формируя большие целые в директиве &FREQU:
		  - неверно печатаются длинные целые со знаком в конструкции:
			_HBpair : DecInt ',' DecInt
		                ={ Ydebug( "... .HB pair: %ld,%ld", $1, $3 );
		                   if( PassNo == 2 ) OutTmp( "%ld,%ld", $1, $3 );
				 }
		  - применение $<longnum>3 не помогло
		  - это DecInt со знаком выдает ерунду, ошибка была здесь -
		    $<longnum>1 вместо $<longnum>2 во втором и третьем правиле:
			DecInt        /* returned signed integer value */
			 :     UnsignDecInt     ={ $<longnum>$ = $<longnum>1;
			                         }
			 | '-' UnsignDecInt     ={ $<longnum>$ = -$<longnum>1;
			                         }
			 | '+' UnsignDecInt     ={ $<longnum>$ = $<longnum>1;
			                         }
			 ;
		TZ0701:	Для диодов: если запустить на трансляцию, то ругаеться
		  на предмет напряжения VJ, которое вроде бы разное, но на самом
		  деле одинаковое и по умолчанию равно 1 - уже исправлено в 1.28
		продолжение TZ0626:
	?	? Есть ошибки: вх - test1.ck1, вых - test1.hb. Проблемы - 
		  1) полностью отсутствуют переменные в &SERV кроме имени
		  2) соответственно, ничего из .hb_options в &SERV не попало
		  - все работает! (?) 
		- В модели диода неравенство ТТ нулю, а М - 1/2 не являеться
		  проблемой (т.е. ошибкой). Надо изменить так, чтобы если TT!=0
		  и/или M!=0.5 программа всего лишь сообщала об этом и изменяла
		  их значения - перевод данных ошибок в разряд информационных
		  предупреждений:
		  - для этого надо в макросе GETANDCHKPARMeqVAL() изменить
		    MsgCompile() на MsgCompileWarn(), но этот макрос
		    используется при генерации других элементов (Oxxx)
		  - его надо заменить на GETDEFCHKPARMeqVAL(), взяв в качестве
		    умолчаний константы def_DiodTT и def_DiodM
		- В выходном файле видно, что у источника внутреннее
		  сопротивление = 0,001, в то время как в конфиг.файле указано
		  0,1. Соответственно определено значение тока = e/r.
		  - похоже, что сейчас хабалятор вообще берет параметры не из
		    конфигурационного файла, а пользуется внутренними
		  - AnalyseConfFile() _изменяет_ параметр, если находит его в
		    конфигурационном файле
		  - AnalyseConfFile() не запускался, так не срабатывает условие
		    if( fileCnf != NULL ) AnalyseConfFile(); /*...*/ - об этом
		    свидетельствует отсутствие в отладочном файле сразу после
		    имен файлов таблицы хабала-параметров, выдаваемой в конце
		    работы AnalyseConfFile(), но почему ???
		  - оказывается, перед if( fileCnf != NULL ) AnalyseConfFile();
		    оказался незакрытый комментарий "/*..."

05.07	1.30	исправления согласно TZ0703:
#107		- неверно обрабатывается частота в источнике distof2:
		  - все параметры, в том числе и F, вычисляются функцией
		    IVxxxParmFromDISTOF(), где F = parm_HB_F2 для DISTOF2,
		    parm_HB_F2 - присваивается глобально из последнего
		    оператора .HB (=&FREQU, параметр F2)
		  - parm_HB_F2 либо не присваивается, либо сбрасывается
		  - в конце оператора .HB присваивание parm_HB_F2 производится
		  - оказывается, в начале каждого оператора этот параметр
		    обнулялся в макросе CLR_ELEM_PARM - это обнуление перенесено
		    в начальные действия *.Y в начале прохода
	!	  ! теперь все работает, но с соблюдением условия:
		    .HB-оператор в исходнике должен появиться _раньше_, чем
		    будут применяться его параметры F1 или F2 в DISTOFах -
		    это связано с тем, что на первом проходе .HB-параметры не
		    запоминаются, так как заказчиком было сформулировано
		    требование "Директива ".HB" может быть не единственной в файле.
		    Каждая последующая полностью переопределяет предыдущую" и
		    с версии 0.76 директив .HB может быть много (в версиях
		    0.59..0.75 он могла быть только одна)
		уточнение по поводу .HB-директивы:
		- .HB-директив в файле может быть несколько
		- учитывается только самая последняя
		- только с последней .HB-директивы берутся данные _для_всех_ источников
		- только с последней .HB-директивы берутся данные для _единственной_
		  &FREQU-команды
		- переделано:
		  - parm_HB_F1 и parm_HB_F2 обрабатываются только на первом
		    проходе, оставляя в конце прохода требуемое значение
		  - обработка &FREQ - та же - все операторы выбрасываются во
		    временный файл, а на выход выводится только последний
	!	  ! побочный эффект: на втором проходе во временный файл попадают
		    все &FREQU-операторы с одинаковыми F1 и F2 от последнего
		    оператора, но на выход попадает только последный - OK

14-8.07	1.31	мелкие исправления:
#108		- для UNIX-версии исправлена ошибка: "/dev/nul" -> "/dev/null"
		- диагностика о завершении 2-го прохода перенесена
		- вместо нее - диагностику msgGENend о завершении генерации
		  (3-го прохода)
	?	при запуске S2H из-под Apache и в некоторых других ситуациях
		  неверно генерируется директива "&SERV" в выходном файле -
		  она содержит только параметр "NAME='...'":
		- в OutHabSERVIS() выдача параметров происходила только при
		  условии "if( Flags[flagD].value )" (только при ключе отладки)
		в исходниках был указан E-mail "a_b@messages.to" службы
		  переадресации, которая закрылась - заменено на "a_b@i.am"

19.07	1.32	начало MESFET (TZ0629):
#109		- добавление новых HB-параметров в файл S2H.CFG
		- SHPASS2.H: добавлены константы моделей для MESFET по умолчанию
		- SHCONFIG.C: добавление HB-параметров во внутреннюю таблицу
		изменение в компиляторе (TZ0724):
		- в директиве .hb убрать все запятые, заменив их пробелами,
		  т.е. теперь эта директива должна выглядеть примерно так:
			.hb f1=110e6 f2=340e8 0 0 1 0 2 0 3 0 
			+                         0 1 0 2 0 3 
			+                         1 1 1 2 1 3
		- состояния анализатора до изменения:
			118/127 terminals, 241/250 nonterminals
			450/500 grammar rules, 801/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3843/5200, parser 934/4000
		- состояния анализатора после изменения:
			118/127 terminals, 241/250 nonterminals
			450/500 grammar rules, 797/1000 states
			0 shift/reduce, 0 reduce/reduce conflicts reported
			241/250 working sets used
			memory: states,etc. 3831/5200, parser 931/4000
		- изменены и контрольные примеры

26.07	1.33	продолжение MESFET (TZ0629):
#110		- PrintElemsTransl()
		- подготовка узлов для хабалы
		- взятие параметра AREA:
		  - static int existMesfetArea; static double parmMesfetArea;
		  - запоминание AREA при разборе опций
		  - если параметр AREA не введен или введен неверно - WI
		    и присвоить def_MesfetAREA
		SHPASS2.C:MkElemZxxx( имя, узлы, модель, parmMesfetArea ):
		- поиск модели в текущей схеме и внешних:
		- тест типа модели: надо NMF или PMF
		~ как и у Dxxx диагностика об отсутствии модели дается в конце
		  строки, так как поиск происходит уже в MkElemZxxx()
	!	- сделана процедура SHpass1.C:UpFindModel() поиска модели
		  в текущей схеме и выше, чтобы диагностику давать в правильном
		  месте (SHpass1.C:FindModel(имя, схема) ищет только в текущей)
		! теперь диагностика об отсутствии модели дается в нужном месте
		! для Dxxx тоже сделана UpFindModel() для диагностики отсутствия
		  модели в нужном месте
		? но теперь выдача диагностики об отсутствующей модели выводится
		  два раза (для элементов в подсхемах):
		  - сообщение выводится дважды одним и тем же оператором
		    (только что добавленным):
		     if( PassNo == 2 ){ /* clear AREA befor process options: */
		       if( UpFindModel( $4 ) == NULL ){ /* find model */
		         MsgCompile( msgMODELNOTFOUND, $4 );
		       }
		     }/*pass2*/
		    заменено на (добавлено условие, при котором генерируется код):
		     if( PassNo == 2 ){ /* clear AREA befor process options: */
		      if( !isSubDefBody /*subcall in main circuit*/ ||
			 ( isSubDefBody && isSubCall && (circCall == circDefCurrent) ) ){
		       if( UpFindModel( $4 ) == NULL ){ /* find model */
		         MsgCompile( msgMODELNOTFOUND, $4 );
		       }
		      }
		     }/*pass2*/

	1.34	продолжение MESFET (TZ0629):
		- в HabElemPart() добавлена часть /* Z -> 'FET ','CURT' */
		- исправлен S2H и в SHconfig.C
		- ввод параметров конфигурации
		- SHpass2.H: добавление комментариев в макросы
		- расчет параметров и проверка соответствия их значений
			/* R1: */

27.07	1.35	продолжение MESFET (TZ0629):
#111		- макросы сделаны в виде блоков, внутри которых описан 'exist':
		  { int exist; ...тело макроса ... }
		- неверно присваивается значение по умолчанию после макроса
		  GETORSETDEFPARMgtVAL(): криво работает MsgCompileWarn():
		    MsgCompileWarn( warn1_INFO, msgPARMVALSETDEF,
					elemname, PARMNAME, modelname, DEF );
		  ? похоже на какой-то побочный эффект:
		  - все начинает работать при вставке отладочной печати
		  ! оказывается, в вызове макроса GETORSETDEFPARMgtVAL(VAL,DEF,
			PARMNAME,PARMVAR,model,modelname,elemname)
		    параметр DEF в данном случае - сам макрос;)
		  ! снова изменение в макросах, учитывающее данную ситуацию:
		   1- присваивание производится _до_ печати сообщения:
		      PARMVAR = DEF;
		    - в сообщении печатается переменная, а не значение по умолчанию:
		      MsgCompileWarn( ..., PARMVAR/* not DEF! */ );
		   2- (там, где нет присваивания) вводится локальная переменная
		      в блоке:
			{ double tmpDEF = DEF; ...
			  MsgCompileWarn( ..., tmpDEF, ... ); ...
			}
		    для единообразия сделан вариант 2 
		- расчет параметров и проверка соответствия их значений
			/* R2: */
			/* R3: */
			/* C12: */
			/* C13: */
			/* ALPHA_H: */
			/* BETA_H: */
			/* LAMBDA_H: */
			/* VTH: */
			/* IS0: */
			/* C230: */
			/* VBI_H: */
			/* AS: */
			/* R31: */
			/* R32: */
			/* UBOUND: */
			/* STEPM: */
		- для последних 4-х параметров в Shconfig.H введены константы
		  значений по умолчанию для проверки и установки правильных
		  значений
	?	только под FreeBSD хабалятор выдает в файл ошибок:
			5685Pass 1 ...
		- может это связано с переназначением /dev/null
		- это происходит в AnalyseConfFile() в цикле и только для FreeBSD
		- этот эффект вызывает пустая строка (только) в начале файла
		  S2H.CFG и, похоже, внутри GetOptNo() - нет:
		- это дает вызов функции для optname="":
			MsgError( msgUNKNWNOPTION, optname ); /**/
	!	- т.е. неверно работает код, вычленяющий optname - виноваты
		  CR в S2H.CFG - убраны CR

09.08	1.36	исправления и дополнения согласно последним ТЗ:
#112		TZ0803:
		в конфиг-файле имена такие:
		    MESFET_RUBOUND=0.555
		    MESFET_RSTERM=0.1111
		  а нужно такие (см док.)
		    MESFET_UBOUND=0.52
		    MESFET_STEPM=0.12
		- изменен S2H.CFG
		- в исходниках заменено:
			MESFET_RUBOUND     -> MESFET_UBOUND
			def_MESFET_RUBOUND -> def_MESFET_UBOUND
			MESFET_RSTERM      -> MESFET_STERM
			def_MESFET_RSTERM  -> def_MESFET_STERM
	?	а это правильные значения:
			# define   def_MESFET_UBOUND   0.52 или 0.5 ?
			# define   def_MESFET_STERM    0.12 или 0.1 ?
		ошибка со времен 0.89 с видимостью имен: например в схеме
		  ...
			.subckt filter 1
				...
			r1 1 0 50
				...
			.ends
		  ...
		  r1 1 0 50	; - здесь выдается ошибка:
			Element with name 'r1' already exist in this circuit
		- ошибка только для элементов главной схемы - внутри подсхем такого
		  не происходит
		- это msgELEMNAMEEXIST, выдается внутри SHpass1.C:AddElem()
		  после el = FindElem( listElem, elemname, parent );
		  при el != NULL
	!	так как макросы SHOWxxx() состоят из нескольких операторов, то
		    if( ... ) SHOWxxx(...);
		    else  ...
		  вызывает ошибку, надо брать в скобки:
		    if( ... ){ SHOWxxx( ... ); }
		    else  ...
		- брать тело макроса в скобки тоже нельзя, так как после
		  макрорасширения получается ";" после "}", что GNU_C не переварил:
		    if( ... ){ ... };
	?	- ошибка в FindElem( listElem, elemname, parent ):
		  при parent==NULL и наличии элемента "elemname" в "listElem"
		  в какой-то подсхеме - ошибка закомментарена (здесь):
		    for( el = listElem; el != NULL; el = el->nextelem )
		        if( streq( elemname, el->elemname ) ){
		        /*if( parent == NULL)          return el; /* in main circ */
		        /*else*/                                    /* - error ! */
		            if( parent == el->parent ) return el; /* in subcirc */
						/* in any subcirc include main */
		        }

23.12	1.37	TZ0C15: изменение в вычислении фазы в обработке источников
#113		  DISTOF1/DISTOF2:
		- фаза источника (Fi) в хабале = pi/2 + (фаза спайс)*pi/180
		  сейчас эта величина постоянна и = -pi/2
		- в функции получения хабала-параметров из DISTOF-значений
		  SHpass2.C:IVxxxParmFromDISTOF():
		    было
		    *Fi = value2 * ( 1 / 180 * const_Pi ) - const_Pi/2;
		    стало
		    *Fi = - const_Pi/2;
		TZ0C13: изменение генерации длинной линии с потерями (эл-т Oxxx):
		  R	>=0, если нет - предупредить, установить 0
		  L	>0
		  G	>=0, если нет - предупредить, установить 0
		  C	>0
		  LEN	>0
		  оба предупреждения - R и G - "КЛАСС 3"
		- для L, C, LEN все так и было сделано
		- SHpass2.C:MkElemOxxx():
		  для R и G заменено:
		    GETORSETDEFPARMeqVAL( 0.0, 0.0, "R", R, model, modelname, elemname );
		    GETORSETDEFPARMeqVAL( 0.0, 0.0, "G", G, model, modelname, elemname );
		  на
		    GETORSETDEFPARMgeVAL( 0.0, 0.0, "R", R, model, modelname, elemname );
		    GETORSETDEFPARMgeVAL( 0.0, 0.0, "G", G, model, modelname, elemname );
		- в SHpass2.H добавлено новое макроопределение:
		    GETORSETDEFPARMgeVAL( ... );
	!	- исправлена ошибка в GETORSETDEFPARMgtVAL(), правда это макро
		  нигде не использовалось ранее:
		    }else if( PARMVAR > VAL ){/* ill parm value: warn, set to def: */\
		  исправлено на
		    }else if( !(PARMVAR > VAL) ){/* ill parm value: warn, set to def: */\
		- аналогично исправлено GETORSETDEFPARMeqVAL() для улучшения
		  читабельности:
		    if( PARMVAR != VAL ) на if( !(PARMVAR == VAL) )
		  этот макрос используется только в MkElemOxxx()
	?	? но GETORSETDEFPARM__VAL() дает диагностику класс_1 (инфо)
		    MsgCompileWarn( warn1_INFO, msgPARMILLVALSETDEF, ... )
		  а не класс_3 (конфликт), поэтому
		- во всех GETORSETDEFPARM__VAL при несоответствии параметра
		  ожидаемому интервалу давать warn3_CONFLICT
		  (все эти макросы используются только в MkElemOxxx())
	?	- при L, C, LEN <= 0 дается ошибка, как и было в старом ТЗ





		TZ0C19: генерация биполярного тр-ра BJT





		TZ0727:
		- Возможность опускать знак "=" распространить и на директивы:
		   .options
		   .hb_options
		   .hb
		  как это сделано для моделей



	?	иногда в директиве  &ELEM переносится одно "/" на следующую
		  строку - это не страшно ?

	?	Сортировка файла узлов по 3+1 столбцу:
		- с помощью библиотечной функции
		- n-кратным просмотром файла, где n-количество строк

		надо делать временный r/w-файл переименования элементов (без
		  заголовка), в конце работы этот файл сортировать, добавлять
		  заголовок и записывать в S2Helems.tmp
		  






--------------------------- отрывать здесь -----------------------------------

Вопросы:
--------
	1.27	? останется нерешенной проблема (случайного) совпадения кодов
		  разных ошибок и присвоения новых при их добавлении в
		  SHmsgEN.H
	нет!	? при выводе диагностики в MsgCompile...() делать (ли?)
		  заворачивание слишком длинных сообщений на следующую строку,
		  если нет, то надо убрать это и для правила
		    ArExpr : Identifier '(' ArExpr ')' /* function or OutVar */
		  (арифметические выражения встречаются в NLDS Bxxx)

	???	в некоторых конструкциях могут быть взяты в скобки и разделены
		  запятыми узлы - попытка это реализовать может перечеркнуть
		  _всю_ проделанную работу, так как вызовет необходимость
		  отказаться от YACC

	?	? а может ли в модели быть несколько параметров-чисел ?

	?	область видимости для определений подсхем:
	0.95	  поиск описания тела подсхемы перед вызовам производится не только
		  в текущей схеме, но и во всех ее предках вплоть до главной
		! а в схемах-братьях не ищется

	?	? если элементов вообще нет, нужно ли выдавать "&TYP IT='End '"

	(doc)	- внутри подсхемы не может быть управляющих операторов
	?	  - здесь может, поэтому это не существенно, или выдавать
		    диагностику ошибки

	?	переименовывать элементы всегда, не пытаясь сохранить
		  оригинальные spice-имена, усекая их до 4-х символов ?
		  (правда сохраняются имена для главной цепи только)


Еще:
----		для экономии дин.памяти запоминать информацию только о моделях
		  используемых типов:
		- LTRA	Lossy transmission line model
		- D	Diode model

		под NT4+GNU найти глюк при работе с памятью/файлами (heap)

		- при занесении элемента из главной цепи в список элементов
		  указатель на подсхему = NULL (добавить в *.Y)
		  - эта информация может служить указанием на то, чтобы
		    при вызове данной подсхемы вновь переименовывать элемент,
		    используя глобальный счетчик переименований (Эл000..Эл999)
		  ! для каждого типа элементов завести свой глобальный счетчик
		    переименований		  

		для экономии можно убрать нетерминалы/правила:
		- Node : NodeName ;  NodeName переименовать назад в Node
		- OptionStartKeyword : Identifier/*KEYWORD*/ ;


================================================================================

-------------------------
Планируется в дальнейшем:
	0.53	? попытка изменить грамматику так, чтобы внутри подсхемы
		  не было управляющих операторов, привела к ошибкам с
		  зависаниями (на примере SUBCKT.SPI) - убрано
		  - надо проверять в управляющих операторах (если надо):
		    if( !isSubDefBody ) обработка управляющего оператора
	0.53	- AddNodeInfo() если isSubDefBody == TRUE сразу прекращается,
		  возвращая -1, в будущем - будет заносить узлы в локальный для
		  подцепи список узлов
		- *.L: не отлажен случай, когда первая строка включаемого файла -
		  титульная (это и не надо)
		- если во включаемом файле встретится .END, не завершать
		  программу вообще, а только вернуться в предыдущий файл (?)

--------------------------
Ограничения / особенности:
	1.22	из-за добавления резисторов в конце первого проходе неверно
		  выдается статистика для _определений_ элементов R - их больше
		  реального количества на число Vxxx-элементов

	1.06	(Txxx) при ошибке в параметре ПАРАМ=ЗНАЧ указатель показывает
		  на первую лексему следующего параметра:
		  - причина - одновременное наличие конструкций
			Param '=' Value
		    и
			Param/*ID*/ '=' Value ',' Value ',' Value ',' Value
		    поэтому распознаватель принимает решение только после
		    прочтения следующей лексемы
	0.88	предел для номеров (имен) хабала-узлов = 9999
		  (поле char newname[5]; - подчиняется ограничению хабала-имени)
	0.87	введены константы lenHABNAME=4, lenHABNAME0=5 (длины хабала-имен)
		! надо помнить, что число 4 используется в спецификации форматов
		  вывода: "%4s"
!	.	описание подсхемы должно начинаться и заканчиваться в одном и
		  том же файле, так как при вызове подсхемы в операторе Xxxx
		  происходит прыжок на подсхему, и если при обработке тела
		  вместо .ends встретится конец файла, то произойдет возврат
		  к следующему за Xxxx оператору, где и будет продолжен поиск
		  .ends для вызванной подсхемы, что некорректно		  
	0.69	функция OutFullCircName(..., указатель) - рекурсивная - уже нет
	0.65	сюрприз: управляющие операторы, заключенные в .control ... .endc
		  могут не начинаться с точки - здесь такого нельзя !
	0.63	макрос yySkipUnput (сброс unput()-буфера) - может быть не
		  переносим
	.	# define    maxINPLINELEN   1000 /* restriction! */
		# define    maxFNAMELEN     250  /* restriction! */
!	0.44	если в описании биполярного транзистора есть 4-й узел (корпус),
		  он не может быть идентификатором, а только числом, иначе
		  появляется 1 конфликт reduce/reduce и все равно не работает
		описание модели не может продолжаться на следующую строку
		  без символа продолжения строки '+', иначе - конфликты и
		  все равно не работает
		возможно зависание при отсутствии .END в конце главного файла
		возможно зависание из-за ошибочного арифметического выражения
		  - зависание вроде устранено, но при ошибке в арифметическом
		    выражении (например, при незакрытой скобке) возможна
		    генерация ошибок в следующих строках, где их реально нет
	!	  ! поэтому рекомендация пользователям: при отладке устранять
		    ошибки по мере их поступления, если это невозможно,
		    то закомментаривать при отладке нужного оператора
		    предыдущие ошибочные операторы
	0.52	? spice-имена, набранные в разных регистрах, отличаются,
		  если отличается регистр только первой буквы (L2 и l2),
		  то на первом этапе генерации хабала-имени у них будут
		  совпадающие имена (L2 и L2), а на следующем этапе одному из
		  них будет присвоено другое имя (L2 и L999)
	0.53	вызовы подцепей игнорируются, описания подцепей не обрабатываются
		  вообще (пока)
	0.55	при исчерпании счетчика переименований элементов одного типа
		  происходит фатальная ошибка, приводящая к прерыванию программы
	!	подцепь может располагаться только в одном файле
		для генерации проекта в системе резервируются диски T: и V:

-------
? ? ? :
	?	надо ли, чтобы данный компилятор обрабатывал
		  директиву вроде #line, чтобы MsgCompile() и консольная
		  диагностика правильно показывала, что обрабатывается
		  при использовании препроцессора?


	?	примеры, взятые с http://www.ee.ualberta.ca/~charro/cookbook/spice/analog/
		  почти все не работают, так как в них встречается конструкция
			EXXXXXXX N+ N- POLY(1) NC+ NC- VALUE
		  вместо описанной в документации
			EXXXXXXX N+ N- NC+ NC- VALUE
	0.76	если на одном уровне попадаются две схемы с одинаковыми именами,
		  то надо ли продолжать обработку, ведь если внутри этих схем
		  будут элементы с совпадающими именами, то это тоже вызовет
		  диагностику, так как тела этих подсхем на первом проходе
		  будут обрабатываться как одна подсхема
	?	- SHpars.Y: добавлен макрос (вызывает "Out of memory" у TC2)
		  #define ADD_NODE_SUBCIRC( name, type, elem ) \
	~	    if( AddNodeInfo( &(circCurrent->circnodlist), \
	~		&(circCurrent->circnodtail),  \
	~		&(circCurrent->cntnodes), name, type, elem ) == NULL \
	~	      ) MsgErrorFatal( exitFAILPASS1, msgFAILADDNODE )
		  который теперь будет использаваться для создания списка узлов
		  в случае, когда circCurrent != NULL:
		  - сделано пока для C, L, R, в остальных случаях пока
		    используется isSubCktDefBody
	?	? есть ли в Хабале комментарии ?
	?	- в примерах обнаружилась конструкция .control ... .endc
	?	- возможен такой .PRINT:
			.print onoise.spectrum > spice3.noise.out
	?	- если арифметическое выражение с ошибкой, возможно зависание
	?	- если оператор ".ends SubCircuit" последний в программе и
		  за ним не идет .end , происходит зависание

-----------------------
Неясно как/что сделать:
	?	осталось разобраться с примерами (ckt.zip):
		- d2.ckt	- Illegal keyword '.control'
				- и еще 'alter', 'write' - добавлены как ключевые
				  слова с точкой вначале
		- v1.ckt	- Illegal keyword '.control'
				? непонятная конструкция dc vin 0 1 0.2
					- вероятно надо .dc vin 0 1 0.2
				- ключевые слова .save и .print без точек впереди
				- в конструкции .print встретились:
				  - недопустимый символ @ в начале параметра
				  - V()
		- r1.ckt	- Illegal keyword '.control'
				- в SAVE недопустимый символ @ в начале параметра
				- обнаружена новая конструкция let Id=ArExpr
				  (принята за индуктивность) - добавлено ключевое
				  слово .LET
	!??	? при повторном запуске Lex на втором проходе под те же
		  стороки, элементы, идентификаторы, идентификаторы-числа
		  снова выделяется динамическая память !
	???	- если в арифметическом выражении встретился _ENDOFSTMT_ (конец
		  строки), это тоже ошибка (в NLDSoption) - обработать пока
		  не удалось - при отсутствии круглой сковки в конце строки
		  происходит:
		  - зависание, если в error-правиле ArExpr делать
		    yyerrok; yyclearin; SkipRestLin();
		  - если делать только yyerrok; yyclearin; то во всех оставшихся
		    до конца файла строках генерируется лавина ошибок о неверном
		    арифметическом выражении
		  + если же ничего не делать, происходит интерпретация следующих
		    строк как продолжения данного выражения до первой требуемой
		    закрывающей скобки, после чего диагностика прекращается
	???	узел S в транзисторе приносит 1 reduce/reduce:
		    TRANSISTOR Node/*C*/ Node/*B*/ Node/*E*/           Identifier ...
		    TRANSISTOR Node/*C*/ Node/*B*/ Node/*E*/ Node/*S*/ Identifier ...
		  сейчас он заменен на bjtSnode, который не может быть идентификатором
	???	в программах без .end может происходить зацикливание
	???	- так как правило
		    Program :
			StatementList error
	        	        ={ MsgCompile( "Need .END at the end of file" );
        	        	   return cntErrors; 
	        	         }
		     /* _ENDOFSTMT_ */
			;
                  завершает работу программы на любом неверном .KEYWORD или
		  KEYWORD, идущем в начале строки вместо имени элемента схемы,
		  например:
		    VOL ...
		    CUR ...
		  можно разкомментарить _ENDOFSTMT_, но это может приводить
		  к зависаниям, если последняя строка программы не пустая
		  и не .END,
		! кроме того, это вызывает конфликт reduce/reduce с правилом
		    StatementItem :
			error
	                	={ MsgCompile( "Error statement" ); YERRSKIP; }
			_ENDOFSTMT_
			;
		- если оно полностью закомментарено, то при отсутствии .END
		  выдается сообщение "*FATAL* Read error on input file"
		  или _зависание_

------------------------
Запомнить и не забывать:

		К вопросу о переносимости: если дается сообщение о том, что
		  не найден прототип ФУНКЦИЯ(), хотя он есть,
		  значит надо писать ФУНКЦИЯ(void)

		Если в форматном выводе печатается более одной long-переменной,
		  то надо не забывать, что формат должен быть %ld , а не %d ,
		  иначе вторая и последующая long-переменная выводится как 0,
		  неверно выводятся и строки (%s) после такой long-переменной
		  (Borland C++ 3.1)

		В GNUшном MAKE-правиле команды должны начинаться только
		  табуляцией, а не пробелами

		MsgCompile() ничего не выдает, если указатель номера строки
		  указывает за пределы файла, но счетчик количества ошибок
		  увеличивает, т.е. могло быть сообщение об общем количестве
		  ошибок без самих диагностик (напр., при отсутствии .END)

		так как в DOS-тексте в конце строки добавляется лишний ^M,
		  в командах UNIXа он воспринимается как символ, внося ошибки,
		  поэтому в скриптах shell/make в конце строки лучше ставить
		  " " или ";"

	!!!	исправить в NCFORM.C:
			yyback(p, m) int *p; {...}
			yyinput() {...>
			yyoutput(c) int c; {...}
			yyunput(c) int c; {...}
		на
			yyback( int *p, int m ) {...}
			yyinput( void ) {...>
			yyoutput( int c ) {...}
			yyunput( int c ) {...}

		так как макросы SHOWxxx() состоят из нескольких операторов, то
		    if( ... ) SHOWxxx(...);
		    else  ...
		  вызывает ошибку, надо брать в скобки:
		    if( ... ){ SHOWxxx( ... ); }
		    else  ...


